## and or

and：当第一句返回True，执行第二句，类似JS的&&，前后不能跟变量名
or：第一句的返回值不管是对错，都执行第二句，类似JS的||，前后不能跟变量名

```python
hasattr(Class, "k") and setattr(class, "k", "v") # 语法正确
a = hasattr(Class, "k") and setattr(class, "k", "v") # 语法正确
a and setattr(class, "k", "v") # 语法错误
hasattr(Class, "k") and a # 语法错误
hasattr(Class, "k") and a = setattr(class, "k", "v") # 语法错误
```

##多进程

```python
# python多进程不可共享对象，如果主进程传给子进程一个对象，子进程对对象进行修改，进程之间的对象值是不同的（但是内存是一体的）
# 对数组做分片，分成n个小数组分配到每个进程。适合千以下小数组
def circulation_process_worker(count, target):
    # 循环多进程
    workers = os.cpu_count()
    print(workers)
    
    def cb(r):
        print(r.result())
        
    """
    ThreadPoolExecutor 为threading的封装。因为有GIL锁的存在, 每个时刻只有一个线程处于运行状态，所以Python无法实现多线程任务并行，适合IO密集
    ProcessPoolExecutor 为 multiprocessing 的封装，可以使用多核，适合CPU密集
    """
    with concurrent.futures.ProcessPoolExecutor() as executor:
        print('处理器数量:' + str(workers))
        for i in range(workers):
            start_idx = int(count / workers * i)
            end_idx = int(count / workers * (i + 1))
            if i == workers - 1:
                end_idx = end_idx - 1
            # 提交一个任务
            future = executor.submit(target, start_idx, end_idx)
            # 增加异步回调
            future.add_done_callback(cb)
    print('完成')
    
circulation_process_worker(数组长度, 方法)

# 适合数量上千的数组
# 不对数组做分片，防止一次塞入大数组导致内存过大
# 循环数组，每次取n个，加入到进程队列
def circulation_process_worker(arr, target):
    
    with concurrent.futures.ProcessPoolExecutor() as executor:
        step = 100 # step在可能范围内越大越好，如果小了需要等待等待较长时间
        # 遍历数组，每次取step个元素
        for sub_arr in [arr[i:i + step] for i in range(0, len(arr), step)]:
            # 对应的参数数组和在后面累加
            for result in executor.map(target, sub_arr, list(map(lambda x: x + 1, sub_arr))):
                # 阻塞直到map中的任务完成
                print(result)
                
circulation_process_worker([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22], 方法)
```

## 内存手动释放

```
import gc
del obj
# 立刻回收
gc.collect()
```

## 初始化固定长度数组

[None] * n

## 合并字典，相同的key相加

```
from collections import Counter
X,Y = Counter(x), Counter(y)
z = dict(X+Y)
```

## Numpy

排序

```kotlin
data[data[:, 1].argsort()] # 按第2列顺序排列，从小到大
data[:, data[1].argsort()] # 按第2行顺序排列，从小到大

data[data[:, 1].argsort()][-1000:]# 取出最大的前n个值，从小到大排列
```

## 数组、字典相互转换

```
data = [{'_id': 'a', 'index': '2'}]
data = [[i['_id'], i['index']] for i in data]
dict(data) # {'a': '2'}

[list(i) for i in data.items()] # [['a', '2']]
```

