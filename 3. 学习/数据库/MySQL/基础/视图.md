# 视图 VIEW
视图是一个虚拟表。是从一个或多个表或视图中导出的表，这些表或视图称作该视图的基本表，视图的结构和数据都是建立在对基本表的查询基础上的。不需要实际的物理空间，视图中的数据是从基本表中选取出来的，这些数据并不实际的按视图结构存储在数据库中，而是存储在原来的基本表中

* 视图不占任何存储空间
* 修改视图会修改原表

作用
* 简化数据
* 隐藏敏感数据
* 生成摘要数据

性能
* **使用视图与使用表有相同的性能**
* 将查询分解为各种视图构成的多个单元，以便简化复杂的查询。这种方法在简化复杂逻辑方面看起来是个好办法，但却会降低性能
* 尽量减少代码中的视图嵌套层数，测试并调整创建视图所用到的语句

## 创建
视图的使用方式与表是一样的，可以像操作表一样从视图里获取数据，需要注意：
* SELECT查询子句的查询内容就是视图的内容
* SELECT语句不允许含有ORDER BY子句和DISTINCT子句。但是可以用group by来起到group by的作用
* 视图列名列表是视图中所包含的列。若使用与基本表中相同的列名，则可以省略。若指定列名列表，则需全部指定，不能只给出一部分。以下情况要求必须指定视图的全部列名：
    1. 由算术表达式、系统内置函数或者常量得到的列
    2. 多表连接查询时选出的同名列
    3. 希望视图中的列名与基表中的列名不同的时候
* WITH CHECK OPTION子句表示在视图上执行UPDATE，INSERT或DELETE操作时要保证所修改的行满足视图定义中的谓词条件（即SELECT查询子句中的限定条件，如Where条件），这样可以确保数据修改后，仍可通过视图看到修改的数据
* 如果用于创建视图的表被删除了，那么这个视图就不可访问了。如果对这个视图做查询，就会收到错误信息
* 视图应只用于select，不建议增删改

```sql
# 创建单源表视图（行列子集视图）（从单个基本表导出的，并且保留了码）
create view tb1_v1 as 
select id, name from tb1
with check option; # 所有在视图上执行的数据修改语句都必须符合创建视图的 SELECT 语句中所设定的条件

select * from tb1_v1;

# 多源表视图：多源表视图是指创建视图时的子查询中用了多个源表。多源表视图一般只用于查询，不用于修改数据
create view tb1_v2 (id, cost, name)
as
select a.id, b.name,
from tb1 a, tb2 b

# 创建基于视图的视图
create view view2
as
select id from view1

# 从视图创建表
create table tb as 
select id, name from view1;
```

## 更新
INSERT UPDATE DELETE
要通过视图更新基表的数据，必须保证视图是可更新视图：
* 视图在创建时FROM子句中没有使用多表连接
* 创建视图的SELECT语句中没有使用GROUP BY、UNION、DISTINCT 子句
* 视图在创建时SELECT子句中没有使用集合运算函数和计算表达式
 
通过可更新视图修改数据的准则
1. 如果在视图创建中使用了 WITH CHECK OPTION 子句，则所有在视图上执行的数据修改语句都必须符合创建视图的 SELECT 语句中所设定的条件。
2. 不能在一个语句中对多个基表使用数据修改语句。
3. 对于基表中需更新而又不允许空值的列，其值须在 INSERT 语句或 DEFAULT 创建中指定。
4. 在基表的列中修改的数据必须符合对这些列的约束，如为非空、检查约束、DEFAULT创建等。
5. 删除视图中的数据须注意：在视图创建的 FROM 子句中只能包含一个表。 

## 删除

```
drop view v_name;
``` 
                      