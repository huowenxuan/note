[TOC]

## 第 1 章 初识Redis

> 五种类型的基本使用方法，加一个投票小案例

一般使用:作为分隔符，也可用./|，保持统一

## 第 2 章 使用Redis构建Web应用

### 登录和cookie缓存

使用hash(散列)保存用户信息

有序集合保存用户访问记录，最多保存1000万个(假设)(或每个用户保存一个月内的10000个)，如果超出，每次删除最老的100个，如果没有达到最大值，休眠1秒再次计数

### 使用Redis实现购物车

每个购物车都是一个hash，保存商品id和数量之间的映射。如果商品数量大于0，添加到hash中，如果hash中已有则覆盖，如果不大于0就从hash中删除

### 数据行缓存

> 对数据的某些字段进行不定期更新缓存

例如促销活动，将需要频繁查询修改的n个字段放一起 toJSON 保存到redis中

（将整个活动每个字段缓存到redis hash中，但是对于标题等字段不需要更新，只需要不定期更新库存等字段即可）

使用两个有序集合来记录应该在何时更新缓存

1. 调度有序集合：key为字段名，值为时间戳，记录应该在何时缓存数据
2. 延时有序集合：key为字段名，值为缓存应该多久更新一次

程序先每50ms循环从集合1中查询是否有需要缓存的数据，如果有，开始缓存数据，并将集合1的时间设置为当前时间+集合2的延迟时间。

可修改2的时间，当为0时删除两个集合对应数据，不再进行更新

（可能会导致超卖）

### 网页分析

> 找出热门数据对它们进行缓存，而非缓存所有

首先需要一个用户浏览记录的有序集合recent:userid

还需要一个记录所有商品浏览次数的有序集合viewed:userid，对浏览次数进行排序，浏览最多的商品放在索引0的位置（？），且具有序集合最少的分值(scope)

```python
redis.add("viewed:" + userid, data, timestamp)
redis.zremrangebyrank('viewed' + userid, 0, -26) // 删除25名之后的浏览
redis.zincrby('viewed:', data, -1) // 减1分
```

需要定期对排行榜数据进行更新，删除排名中多余的商品，并将剩余商品的浏览次数减半

zinterstore将一个或多个有序集合求并集并计算，生成一个新的集合

```python
redis.zremrangebyrank("viewed:", 0, -20001) // 删除2000名之后的商品
redis.zinterstore("viewed:", {'viewed': .5}) // 将浏览次数降低为原来的一半
```

最终可将前10000个商品进行缓存