##JavaScript 类
>JavaScript 是面向对象的语言，但 JavaScript 不使用类。  
在 JavaScript 中，不会创建类，也不会通过类来创建对象（就像在其他面向对象的语言中那样）。  
JavaScript 基于 prototype，而不是基于类的。  
注意：从传统意义上来说，ECMAScript 并不真正具有类。事实上，除了说明不存在类，在 ECMA-262 中根本没有出现“类”这个词。ECMAScript 定义了“对象定义”，逻辑上等价于其他程序设计语言中的类。术语为“对象”

##Object 对象
>Object 对象自身用处不大，不过在了解其他类之前，还是应该了解它。因为 ECMAScript 中的 Object 对象与 Java 中的 java.lang.Object 相似，ECMAScript 中的所有对象都由这个对象继承而来，Object 对象中的所有属性和方法都会出现在其他对象中，所以理解了 Object 对象，就可以更好地理解其他对象。

Object 对象具有下列属性：  
####constructor  
```javascript
// 构造函数：其实就是一个普通函数，但是内部使用了this变量，对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。
function Cat(name, color) {
    this.name = name;
    this.color = color;
}
var cat = new Cat('d', 'd')
// constructor属性指向构造函数,也就是上面的函数
console.log(cat1.constructor); // [Function: Cat]
```

####prototype
>原型。也表示一个类的成员的集合。使用它向对象添加属性和方法  
object.prototype.name=value  
和object.name 不同，通过prototype的方法添加的属性和方法可以在子类中使用，就是向内部添加属性方法，而不仅仅是向实例添加  
Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。那么不管有几个子类，都是访问同一个prototype地址，是同一个对象  
这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上，防止创建多个相同的实例导致多占用内存
Cat.prototype.type = "猫科动物";

####Object 对象还具有几个方法：
isPrototypeOf():  
判断某个proptotype对象和某个实例之间的关系。  
Cat.prototype.isPrototypeOf(cat1); //true

hasOwnProperty(property):  
判断是否具有某个属性
cat1.hasOwnProperty("name"); // true
cat1.hasOwnProperty("theype"); // false

in运算符:  
判断某个实例是否含有某个属性，不管是不是本地属性。 也可以判断某个键是否在map中，不可判断某个值是否在array中
"name" in cat1; // true  
"type" in cat1; // true  
in运算符还可以用来遍历某个对象的所有属性。
```javascript
for(var prop in cat1) {  
  "cat1["+prop+"]="+cat1[prop];
}  
```

PrototypeOf(object):  
判断该对象是否为另一个对象的原型。  

propertyIsEnumerable:  
判断给定的属性是否可以用 for...in 语句进行枚举。  

toString():  
返回对象的源代码，调试有用

valueOf():  
返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。

```javascript
/**
 * 对象 Object
 * JavaScript 中的所有事物都是对象：字符串、数值、数组、函数...
 * JavaScript 提供多个内建对象，比如 String、Date、Array 等等。
 * 对象只是带有属性和方法的特殊数据类型。本质上是键值对的集合（Hash结构）
 */

// 创建
// 第一种: 创建直接的实例
var person = new Object();
person.name = 'Huo';
person.age = 20;
// 也可以:
var person2 = {name: 'Huo', age: 20};

// 第二种: 使用对象构造器构造对象:
function Person2(name, age) {
    this.name = name;
    this.age = age;
}
var person2 = new Person2('Huo', 20);

// 第三种:
// 参数
var Sales = "Toyota";
// 方法
function CarTypes(name) {
    return (name === "Honda") ?
    name :
    "Sorry, we don't sell " + name + "." ;
}
// 对象
var car = {
myCar: "Saturn",
getCar: CarTypes("Honda"),
special: Sales
};
console.log(car.myCar);   // Saturn
console.log(car.getCar);  // Honda
console.log(car.special); // Toyota

// 添加新属性和新方法:
car.name = 'Hello';
// 更进一步的，你可以使用数字或字符串作为属性的名字。如下的示例中使用了这些可选项。
var car = {
manyCars: {a: "Saab", "b": "Jeep"},
    7: "Mazda"
};
console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda

// 对象属性名字可以是任意字符串，包括空串。如果对象属性名字不是合法的javascript标识符，它必须用""包裹。属性的名字不合法，那么便不能用.访问属性值，而是通过类数组标记("[]")访问和赋值。
var unusualPropertyNames = {
    "": "An empty string",
    "!": "Bang!"
}
// console.log(unusualPropertyNames."");   // 语法错误: Unexpected string
console.log(unusualPropertyNames[""]);  // An empty string
// console.log(unusualPropertyNames.!);    // 语法错误: Unexpected token !
console.log(unusualPropertyNames["!"]); // Bang!

// 注意
var foo = {a: "alpha", 2: "two"};
console.log(foo.a);    // alpha
console.log(foo[2]);   // two
//console.log(foo.2);  // Error: missing ) after argument list
//console.log(foo[a]); // Error: a is not defined
console.log(foo["a"]); // alpha
console.log(foo["2"]); // two


// 对象废除
car = null
// 每用完一个对象后，就将其废除，来释放内存，这是个好习惯。这样还确保不再使用已经不能访问的对象，从而防止程序设计错误的出现。
// 注意：废除对象的所有引用时要当心。如果一个对象有两个或更多引用，则要正确废除该对象，必须将其所有引用都设置为 null。
```


