```javascript
 // 创建：第一种：直接创建
function square1(number) {
    return number * number;
}
var x = square1(4); // 调用

// 第二种：创建Fundation对象
// 定义一个函数
function doAdd(num){
    return num + 20;
}
// 使用Function创建刚刚的函数
var doAdd2 = new Function('num','return num+20');
console.log(doAdd2(20)); // 输出40
// 因为Funcation也是对象,所以也有属性和方法以及对象的公共属性和方法
// 尽管可以使用 Function 构造函数创建函数，但最好不要使用它，因为用它定义函数比用传统方式要慢得多。不过，所有函数都应看作 Function 类的实例。


// 函数表达式
// 匿名函数
var square2 = function (number) {
    return number * number;
}
var x = square2(4); // 调用

// 非匿名函数
var square3 = function fname(number) {
    return number * number
}
var x = square3(4);

// 将函数作为参数调用
function square4(f, a) {
    return f(4) * a;
}
var x = square4( function(x) { return x * x }, 4) // 结果为:64

// 函数调用在声明之前
// 只能这样调用
square5(4) // 先调用
function square5(n) {return n * n} // 再声明
// 这种方式不可以:
// square6(4)
// var square7 = function (n) {
//     return n * n;
// }

// 构造函数：其实就是一个普通函数，但是内部使用了this变量，对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。
function Cat(name, color) {
    this.name = name;
    this.color = color;
}


// 作用域: 函数外无法得到函数内的变量,函数内可以得到函数的外部以及父函数的变量
// 嵌套函数
var num1 = 1;
function aaa() {
    var num2 = 2;
    aa();
    function aa() {
        var num3 = 3;
        a();
        function a() {
            var num4 = 4;
            // 可以访问num1,num2,num3,num4
        }
    }
}
// 可以访问num1,不可以访问num2,num3,num4

/**
 * 闭包:
 * 嵌套函数的内部函数形成了一个闭包: 它可以访问外部函数的参数和变量,外部不能使用内部的参数和变量
 * 生命周期:当内部函数生存周期大于外部函数时，由于内部函数可以访问外部函数的作用域，定义在外部函数的变量和函数的生存周期就会大于外部函数本身。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。
 */

// 命名冲突: 当同一个闭包作用域下两个参数或者变量同名时，就会产生命名冲突。更近的作用域有更高的优先权，所以最近的优先级最高，最远的优先级最低。这就是作用域链。链的第一个元素就是最里面的作用域，最后一个元素便是最外层的作用域。

// this: 每一个新函数都重新定义了自己的this值（在严格模式下，一个新的对象在构造函数里是未定义的，通过上下文对象调用的函数被称为“对象方法”等）。面向对象的编程风格着实有点恼人。
function Person() {
    this.age = 0;
    
    setInterval(function growUp() {  // setInterval定时器,第一个参数为执行的函数,第二个参数为时间间隔
                this.age++; // 访问的是growUp的环境,无age,所以NaN
                // console.log(this.age) // 输出NaN
                }, 1000)
}
var p = new Person();

// 解决
function Person2() {
    this.age = 0;
    
    var me = this; // 将外部函数的this赋值给me
    setInterval(function growUp() {
                me.age++; // 访问外部成功
                // console.log(me.age);
                }, 1000)
}
var p2 = new Person2();

/*
 // ES6新语法:默认参数 剩余参数
 // 默认参数
 function defaultParameterFunc(a, b = 1) { // b默认为1
 }
 
 // 剩余参数: 允许将不确定数量的参数表示为数组
 function addFunc(a, ...numArr) {
 var result = a;
 for (var num in numArr) {
 result += num;
 }
 return result;
 }
 console.log(addFunc(1,2,3));
 */

// 箭头函数(永远都是匿名的): 箭头功能捕捉闭包上下文的this
function Person3() {
    this.age = 0;
    
    setInterval(() => {
                this.age++; // 在箭头函数中访问成功
                console.log(this.age)
                }, 1000);
    
}
var p3 = new Person3();

```
