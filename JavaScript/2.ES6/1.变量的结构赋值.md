```javascript
/**
 * ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
 */

/**
 * 数组解构
 */
var [a, b, c] = [1, 2, 3]; // a=1,b=2,c=3
var [, , three] = ['one', 'two', 'three'];

var [head, ...tail] = [1,2,3,4]; // head=1,tail=[2,3,4]

var [x, y, ...z] = ['a']; // x=a, y=undefined 解构失败, z=[]

var [foo, [[bar], baz]] = [1, [[2], 3]]; // foo=1,bar=2,baz=3

var [foo] = []; // 失败,foo=undefined
var [bar, foo] = [1]; // bar=1,foo=undefined

var [x,y]=[1,2,3]; // 不完全解构,但是成功。x=1,y=2
var [a, [b], d] = [1, [2, 3], 4]; // 不完全解构,但是成功。a=1, b=2, d=4

// 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，那么将会报错。
// let [foo] = 1;
// let [foo] = false;
// let [foo] = NaN;
// let [foo] = undefined;
// let [foo] = null;
// let [foo] = {};
// 上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。

// 默认值
var [foo = true] = []; // 如果解构失败,就使用默认值

// 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
function f() {
    console.log('aaa');
}
var [x = f()] = [1];

// 默认值可以引用解构赋值的其他变量，但该变量必须已经声明
// let [x = 1, y = x] = [];     // x=1; y=1
// let [x = 1, y = x] = [2];    // x=2; y=2
// let [x = 1, y = x] = [1, 2]; // x=1; y=2
// let [x = y, y = 1] = [];     // ReferenceError



/**
 * 对象解构
 */
// 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
var {foo, baz} = {foo: 'aaa', bar: 'bbb'}; // foo=aaa, baz=undefined

// 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。
// 对属性进行解构
var {foo: baz} = { foo: "aaa", bar: "bbb" }; //baz: aaa, foo:错误: foo is not defined

/**
 * 字符串解构
 */
var [a,b,c,d,e] = 'hello';
// 对length属性解构
var {length: len} = 'hello'; // len=5


/**
 * 函数参数的解构
 */
function add([x, y]) {
    return x + y;
}
add([1, 2]); // 函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。

// 使用默认值
function move({x=0, y=0} ={}) {
    return [x, y];
}
move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]

// 为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。
function move({x, y} = { x: 0, y: 0 }) {
    return [x, y];
}
move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]

/**
 * 圆括号问题
 * 解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。
 * 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。
 * 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。
 */

// 不能使用圆括号的情况
//（1）变量声明语句中，不能带有圆括号。
// 全部报错.因为它们都是变量声明语句，模式不能使用圆括号。
// var [(a)] = [1];
// var {x: (c)} = {};
// var ({x: c}) = {};
// var {(x: c)} = {};
// var {(x): c} = {};}
// var { o: ({ p: p }) } = { o: { p: 2 } };

//（2）函数参数也属于变量声明，不能带有圆括号。
// 报错
// function f([(z)]) { return z; }

//（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。
// 全部报错
// ({ p: a }) = { p: 42 };
// ([a]) = [5];
// [({ p: a }), { x: c }] = [{}, {}];

// 可以使用圆括号的情况
// 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。
[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确

/**
 * 用途
 */
// (1)交换变量的值
[x, y] = [y, x];

// (2)从函数返回多个值
// 返回一个数组
function example() {
    return [1, 2, 3];
}
var [a, b, c] = example();
// 返回一个对象
function example2() {
    return {
        foo: 1,
        bar: 2
    };
}
var { foo, bar } = example2();

//（3）函数参数的定义。解构赋值可以方便地将一组参数与变量名对应起来。
// 参数是一组有次序的值
function f([x, y, z]) { }
f([1, 2, 3]);
// 参数是一组无次序的值
function f({x, y, z}) { }
f({z: 3, y: 2, x: 1});

//（4）提取JSON数据
var jsonData = {
    id: 42,
    status: "OK",
    data: [867, 5309]
};
let { id, status, data: number } = jsonData;
console.log(id, status, number);
// 42, "OK", [867, 5309]

// (5)函数参数的默认值

//（6）遍历Map结构
// 任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。
var map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
    console.log(key + " is " + value);
}
// first is hello
// second is world
// 如果只想获取键名，或者只想获取键值，可以写成下面这样。
// 获取键名
for (let [key] of map) {
    // ...
}
// 获取键值
for (let [,value] of map) {
    // ...
}

//（7）输入模块的指定方法
// 加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。
var {
    NavigatorIOS,
    AlertIOS
} = require("react-native");
```
