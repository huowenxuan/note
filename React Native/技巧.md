[TOC]

# 直接使用文件名引用文件，而不使用路径引用
在该文件开头加入

```javascript
/**
 * @providesModulePromptLabel
 */
 class MyClass {
 }
```
引用
```javascript
import MyClass from 'MyClass' 
```

# ListView 标签流式布局

```
contentContainerStyle={styles.listContainer}
listContainer:{
flexDirection:'row',
flexWrap:'wrap',
},

```
**这种方式只能实现类似标签的高度相等，宽度不同的布局，不能实现高度不同，宽度相同的瀑布流布局**
row的最外层需要设置确定的高度

# ListView 瀑布流

row设置为绝对布局，计算位置

# renderRow执行的次数比dataSource的数量少
如果出现renderRow执行的次数比dataSource的数量少的情况，  
需要设置:  
`initialListSize={20} // 可以把值改为dataSource的length`  
如果不设置,renderRow只能执行前几条数据, 想显示其他数据, 只能通过改变任意state来实现


# 下拉图片放大，上拉视差效果
![效果](./media/2.gif)

先举个例子，你可能希望你的Animated.Value从0变化到1时，把组件的位置从150px移动到0px，不透明度从0到1。可以通过以下的方法修改style属性来实现：

```javascript

class Article extends Component {
  constructor(props) {
    super(props);

    this.state = {
      scrollY: new Animated.Value(0),
    }
  }

  _renderHeaderParallaxImage() {
    const { boardData } = this.props;
    const {scrollY} = this.state

    let navH = Platform.OS == 'ios' ? 64 : 44

    let translateY
    if (Platform.OS == 'ios') {
      translateY = scrollY.interpolate({
        inputRange: [255-64+50, 255+(64 - 50), 255+(64 - 50)],
        outputRange: [255, 255-30, 255-30],
      })
    } else {
      translateY =  scrollY.interpolate({
        inputRange: [255-44+30+20, 255-30+44+20, 255-30+44+20],
        outputRange: [255, 255-30, 255-30],
      })
    }

    return (
      <Animated.Image
        style={[styles.postParallaxImage, {
          height: 255,
          transform: [{
            translateY: scrollY.interpolate({
              inputRange: [-255, 0, 255-navH, 255],
              outputRange: [255 / 2, 0, -(255-navH), -(255-navH)],
            })
          }, {
            scale: scrollY.interpolate({ 
              inputRange: [-255, 0, 255],
              outputRange: [2, 1, 1], // -255: 2, 0: 1, 255: 1  当scrollY在-255到0时，scale按照2-1的动画运动；当scrollY在0-255时，scale不变。可以输入任意数量对应的值，但必须是递增或者相等
            })
          }]
        }]}
        source={boardData.cover_key ? {uri: boardData.cover_key} : require('../images/q_small.jpg')}
      >
        <Animated.Text style={{
          color: 'white',
          backgroundColor: 'transparent',
          fontSize: 18,
          textAlign: 'center',
          transform: [{translateY: translateY}]
        }}>
          {boardData.title}
        </Animated.Text>
      </Animated.Image>
    )
  }

  render() {
    return (
        <ListView
          // 把Animated.event绑定到onScroll或者手势中，动画很流畅，比使用Animated.timing流畅很多。
          onScroll={Animated.event([{nativeEvent: {contentOffset: {y: this.state.scrollY}}}])}	
          // 或者
          onScroll={(e)=>{
            Animated.event([{nativeEvent: {contentOffset: {y: this.state.scrollY}}}])
              .call(this, e)
          }}
          // 设置为16帧刷新足够了，不需要设置为1
          scrollEventThrottle={16}
        />
        {this._renderHeaderParallaxImage()}
    );
  }
}
```

# 得到text的高度

```javascript
<Text onLayout={(event)=>this._textOnLayout(event)} />

_textOnLayout(event){
	console.log(event.nativeEvent.layout.height,'onLayout');
}
```

# ListView从下向上排列

```javascript
<ListView contentContainerStyle={styles.listViewContent}/>
listViewContent:{
	flex:1,
	//从下向上排列
	justifyContent:'flex-end'
}
```

# 得到组件宽高

```javascript
this.refs.row.measure(function(ox,oy,width,height,px,py){
	cellHeight=height;
});

<View style={styles.row}ref="row"/>

row:{
	flex:1,
	backgroundColor:'#FFFFFF',
	borderTopWidth:1/2,
	borderBottomWidth:1/2,
	borderColor:'#dddddd',
	marginTop:10/2,
	marginBottom:10/2
},
```

# 指定某个组件

```javascript
var _listView: ListView;
<ListView ref={(listView)=>{_listView=listView;}}/>
```

# 版本更新
```javascript
openAppStore: ()=> {
  var url = '';
  if (Platform.OS === 'ios') {
    url = 'itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&onlyLatestVersion=true&pageNumber=0&sortOrdering=1&id=1156814163';
  } else {
    url = 'http://a.app.qq.com/o/simple.jsp?pkgname=com.girtu.girtu'
  }

  Linking.openURL(url).catch(err => console.error('An error occurred', err));
},

checkoutUpdate: ()=> {
  let setLaterUpdateTime = (time) => {
    AsyncStorage.setItem('update_time', time);
  }

  let getLaterUpdateTime = () => {
    return AsyncStorage.getItem('update_time')
  }

  // 点击了稍后更新, 保存当前时间
  let laterUpdate = ()=> {
    setLaterUpdateTime(new Date().toString())
  }

  // 点击立即下载只是跳转到商店,本地不做处理,如果没有更新,下次进入依然提醒
  // 点击稍后下载,本地记录时间,10天后再次提醒
  let showAlert = ()=> {
    Alert.alert('有新版本发布, 是否更新', '', [
      {text: '马上下载', onPress: ()=>module.exports.openAppStore()},
      {text: '稍后更新', onPress: ()=>laterUpdate()}
    ])
  }

  // 计算时间差, 如果大于10天就显示alert, 否则什么都不做
  let calculateDateDiff = (oldDate)=> {
    oldDate = new Date(oldDate)
    let newDate = new Date(); //结束时间
    let differDate = newDate.getTime() - oldDate.getTime(); //时间差的毫秒数
    let days = Math.floor(differDate / (24 * 3600 * 1000)); ////计算出相差天数
    if(days >= 10) {
      showAlert()
    }
  }

  setTimeout(()=> {
    // 假设获取到版本号后
    let newVersion = '2.3.3';
    let oldVersion = DeviceInfo.getVersion();
    if (newVersion > oldVersion) {
      getLaterUpdateTime()
        .then((oldDate)=> {
          // 如果有时间就计算时间差, 没有时间就直接显示
          if (oldDate) {
            calculateDateDiff(oldDate)
            // calculateDateDiff(1489075200000)
          } else {
            showAlert()
          }
        })
        .catch((e)=> {
          showAlert()
        })
    }
  }, 2000)
},
```

