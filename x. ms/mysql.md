[TOC]

[MySQL常见面试题](https://www.cnblogs.com/hsmwlyl/p/10719152.html)

[Mysql面试题（通俗）](https://www.cnblogs.com/yangk1996/p/12864004.html)

### 分布式

zookeeper

### char和varchar

char固定长度、varchar可变长度；char速度快，但是浪费存储空间；在myisam中，对于长度基本相同的优先使用char，相差很大的使用varchar。在innodb中，内部并没有区分可变和固定长度，都指向数据的头指针，所以char的性能不一定比varchar好，又由于char平均空间多余varchar，所以建议使用varchar

### 事务四大特性

- 原子性：不可分割的操作单元，事务中所有操作，要么全部成功；要么撤回到执行事务之前的状态
- 一致性：如果在执行事务之前数据库是一致的，那么在执行事务之后数据库也还是一致的；
- 隔离性：事务操作之间彼此独立和透明互不影响。事务独立运行。这通常使用锁来实现。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。
- 持久性：事务一旦提交，其结果就是永久的。即便发生系统故障，也能恢复。 

### MySQL的事务隔离级别

并发问题

* 脏读：在一个事务处理过程里读取了另一个未提交的事务中的数据
* 不可重复读：对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了
* 幻读： 在一个事务的两次查询中的结果数量不一致

脏读和不可重复读的区别是：事务的提交和未提交

不可重复度和幻读的区别是：不可重复的针对修改，幻读针对增加或删除

隔离级别。级别越高性能越低

* 未提交读(Read Uncommitted)：所有事务都可以看到其它事务未提交的数据。此隔离级别没有解决任何并发问题，不常用
* 提交读(Read Committed)：一个事务只能读取其它事务已经提交的数据。此隔离级别解决了脏读。是大多数数据库的默认隔离级别
* 可重复读(Repeated Read)：**同一个事务内的查询都是事务开始时刻一致的**。此隔离级别解决了脏读和不可重复读，是MYSQL的默认级别
* 串行读(Serializable)：最高的隔离级别。事务事务之间只能顺序执行。每次读都需要获得表级共享锁，读写相互都会阻塞。序列化解决了脏读，不可重复读和幻读

### 索引

索引是一个排序的数据结构，通常使用B+树，来指向真实的数据，可实现高级查找方法

缺点是增加了数据库存储空间；在插入和修改时需要花费较多时间，因为索引也会随之变动；创建和维护索引也会消耗时间。

普通索引（常用来where的普通字段）、主键索引（建表自动创建，不允许为空）、唯一索引（不允许重，可以为空）、组合索引（多个字段联合索引）

### 锁

锁粒度

* 行锁：Innodb默认，开销大、加锁慢，会死锁，粒度最小，并发度高

* 表锁：myisam默认，开销小，加锁快，不会死锁，并发度最低

* 页面锁：开销和加锁时间中等，会死锁，并发度一般

锁机制：

* 共享锁（读锁）：读取操作创建的锁，其他用户可以读取数据，但任何事务都不能对数据进行修改（不能获取排他锁）

* 排他锁（写锁）：事务对数据加上排他锁后，则其他事务不能再对它加任何类型的锁。获准排他锁的事务既能读数据，又能修改数据

悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。行锁、表锁、读锁、写锁都是悲观锁。适用于多写的情况

乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。可用代码通过比较数据版本实现，适用于写少读多的情况，省去锁的开销

### myisam与 innodb

myisam性能强，执行速度快，不支持事务

innodb支持事务、外键

InnoDB 支持行级锁，而 MyISAM 支持表级锁。行级锁对于高并发有很好的适应能力

MyISAM每个表保存为3个文件，备份恢复可单独对某个表操作。innodb所有数据表保存在一个文件，在数据量大了之后就比较痛苦了

### 优化

TODO