[TOC]

### Redis为什么这么快

1. 运行在内存中
2. 单线程，避免线程切换的开销（redis瓶颈不是cpu运行速度，而是网络宽带和计算机内存）
3. C语言实现 + 代码优雅 + 数据结构简单
4. 非阻塞的i/o多路复用（就是很多网络连接，共用少数几个(甚至是一个)线程。
   连接很多的时候，不能每个连接一个线程，线程也不能阻塞在任何一个连接上，也不能用非阻塞方式，轮询所有的连接，这会浪费掉大量CPU时间；只能告诉系统，我对哪些连接感兴趣，有消息来的时候，通知我处理）

### 有什么办法发挥多核CPU的性能

单机开多个Redis 实例

### Redis怎样防止异常数据不丢失

> **RDB 持久化**
> 将某个时间点的所有数据都存放到硬盘上。
> 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。
> 如果系统发生故障，将会丢失最后一次创建快照之后的数据。
> 如果数据量很大，保存快照的时间会很长。
> **AOF 持久化**
> 将写命令添加到 AOF 文件（Append Only File）的末尾。
> 使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：
> 选项同步频率always每个写命令都同步everysec每秒同步一次no让操作系统来决定何时同步
> **always** 选项会严重减低服务器的性能；
> **everysec** 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
> **no** 让操作系统来决定，并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量
> 随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 压缩的命令

### Redis值的五种类型

string、hash、list、set、zset

### 使用过Redis做异步队列么，你是怎么用的？有什么缺点？

一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等

能不能生产一次消费多次呢？

使用pub/sub主题订阅者模式，可以实现1:N的消息队列。（传输可靠性低，如果客户端在执行订阅中短线，那么客户端将在丢失断线期间发送的所有消息）

### 缓存穿透

一般的系统先去去查找redis缓存，如果未找到，就去数据库中查找，而当这个数据在数据库中也不存在时，就会造成缓存穿透。如果访问过多会对数据库造成极大压力，一般是攻击造成

避免：对数据库查询结果为空的情况也进行缓存（缓存为-1或者空字符串等），缓存时间设置短一点

### 缓存雪崩

当redis重启或者大量缓存集中在一个时间段失效，会给后端系统带来很大压力。导致系统崩溃。

避免：

1. 根据热度或类型，设置不同的过期时间或者随机时间
2. 通过加锁来控制。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待
3. 如果是缓存是分布式，将热点数据均匀分布在不同缓存数据库中
4. 可设置热点数据永不过期

### 缓存击穿

一个key非常热点，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库

避免：

1. 缓存预热：对于秒杀等直接提前缓存，永不过期或过期时间加大
2. 热门数据永不过期
3. 加锁，第一个请求持有锁，去访问数据库，其他的等待

### 高可用和分布式

高可用实现Redis Sentinel，独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换
分布式实现Redis Cluster，提供了读写、容量的扩展，将数据分配在不同的实例中

### 事务

watch监听key，当exec执行后发现数据已经发生变化，会报错（乐观锁）；multi：将这个客户端之后的所有命令放入队列中，直到exec，exec执行完成后，redis才会执行其他客户端的命令

事务的好处之一就是客户端会通过使用流水线来提高事务执行时的性能（只在exec才发送命令）

为什么Redis没有实现加锁功能：为了减少客户端等待时间，不会在watch时加锁，只会在其他客户端修改后通知执行了watch的客户端，这种做法为乐观锁，只需要在事务执行失败时重试即可

### 主从模式

复制：主服务器向多个从服务器发送更新，从服务器处理所有读请求

执行slaveof后的复制启动过程：

| 步骤 | 主服务器操作                                                 | 从服务器操作                                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | 等待命令进入                                                 | 连接或重连接主服务器，发送sync命令                           |
| 2    | 自动执行bgsave（RDB），并缓冲区记录bgsave之后执行的所有写命令 | 根据配置来决定是继续用现有数据处理客户端的命令请求，还是向客户端返回错误 |
| 3    | bgsave执行完毕，向从服务器发送快照文件，发送期间继续使用缓冲区记录 | 丢弃所有旧数据，开始使用快照                                 |
| 4    | 快照发送完毕，开始向从服务器发送缓冲区的写命令               | 完成对快照的解释操作，开始接受命令请求                       |
| 5    | 缓冲区写命令发送完毕。每执行一次写命令，就向从服务器发送相同的写命令 | 接收并执行主服务器传来的每个写命令                           |

**从服务器同步会清空数据**；**Redis不支持主主复制**

主从链：当读请求的重要性明显高于写请求，且读请求的数量远高于一台redis服务器可以处理的范围时，就需要添加新的从服务器，主服务器可能无法快速地更新所有从服务器，就需要建立**从服务器的从服务器**来分担主服务器的复制工作

### 优化

1. 缩短键值对的存储长度，必要时进行压缩
2. 设置键的过期时间
3. 使用Pipeline管道批量操作数据
4. 使用AOF，策略为每秒同步一次
   1. Master不要做持久化（快照写入对性能影响非常大，AOF文件过大会影响Master重启速度）
   2. 对某个Slave开启AOF备份，策略为每秒一次

### 分布式锁

最简单的setnx，为了保证原子性，能正确释放锁，使用lua脚本实现