[TOC]

### Redis为什么这么快

1. 运行在内存中
2. 单线程，避免线程切换的开销，实现简单（redis瓶颈不是cpu运行速度，而是网络宽带和计算机内存）
3. C语言实现 + 代码优雅 + 数据结构简单
4. 非阻塞的i/o多路复用（就是很多网络连接，共用少数几个(甚至是一个)线程。
   连接很多的时候，不能每个连接一个线程，线程也不能阻塞在任何一个连接上，也不能用非阻塞方式，轮询所有的连接，这会浪费掉大量CPU时间；只能告诉系统，我对哪些连接感兴趣，有消息来的时候，通知我处理）

### 有什么办法发挥多核CPU的性能

单机开多个Redis 实例

### Redis怎样防止异常数据不丢失

> **RDB 持久化**
> 将某个时间点的所有数据都存放到硬盘上。
> 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。
> 如果系统发生故障，将会丢失最后一次创建快照之后的数据。
> 如果数据量很大，保存快照的时间会很长。
> **AOF 持久化**
> 将写命令添加到 AOF 文件（Append Only File）的末尾。
> 使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：
> 选项同步频率always每个写命令都同步everysec每秒同步一次no让操作系统来决定何时同步
> **always** 选项会严重减低服务器的性能；
> **everysec** 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
> **no** 让操作系统来决定，并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量
> 随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 压缩的命令

### Redis值的五种类型

string、hash、list、set、zset

### 使用过Redis做异步队列么，你是怎么用的？有什么缺点？

一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等

能不能生产一次消费多次呢？

使用pub/sub主题订阅者模式，可以实现1:N的消息队列。（传输可靠性低，如果客户端在执行订阅中短线，那么客户端将在丢失断线期间发送的所有消息）

### 缓存穿透

一般的系统先去去查找redis缓存，如果未找到，就去数据库中查找，而当这个数据在数据库中也不存在时，就会造成缓存穿透。如果访问过多会对数据库造成极大压力，一般是攻击造成

避免：

对数据库查询结果为空的情况也进行缓存（缓存为-1或者空字符串等），缓存时间设置短一点

### 缓存雪崩

当redis重启或者大量缓存集中在一个时间段失效，会给后端系统带来很大压力。导致系统崩溃。

避免：

1. 根据热度或类型，设置不同的过期时间或者随机时间
2. 通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待
3. 如果是缓存是分布式，将热点数据均匀分布在不同缓存数据库中
4. 可设置热点数据永不过期

### 缓存击穿

一个key非常热点，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库

避免：

1. 缓存预热：对于秒杀等直接提前缓存，永不过期或过期时间加大
2. 热门数据永不过期
3. 互斥锁，第一个请求持有锁去访问数据库，其他的等待，并且每隔几十毫秒重新查找一次，直到获取成功

### 高可用和分布式

高可用实现Redis Sentinel，独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换
分布式实现Redis Cluster，提供了读写、容量的扩展，将数据分配在不同的实例中

### 事务

multi和exec在执行exec后才会有实际操作，所以没办法根据读取到的数据来做决定

通过使用watch、multi/exec、unwatch/discard等命令，可确保自己正在使用的数据没有发生变化来避免出错

```
// 使用watch对key监听后，直到exec这段时间里，如果有其他客户端抢先对key进行了写操作，执行exec时，事务将失败并返回错误。
watch key

// watch执行后、multi执行前对连接进行重置（取消监听）
unwatch

// multi执行后、exec执行前对连接进行重置，取消监听，清空已入队的任务
discard
```

为什么Redis没有实现加锁功能：典型的关系型数据库加锁的缺点是持有锁的客户端运行越慢，等待解锁的客户端被阻塞的时间就越长，redis为了减少客户端等待时间，不会在watch时加锁，只会在其他客户端修改后通知执行了watch的客户端，这种做法为乐观锁，只需要在事务执行失败时重试即可，关系数据库的锁为悲观锁

执行事务的好处之一就是客户端会通过使用流水线来提高事务执行时的性能（只在exec才发送命令）

### 主从模式

复制

> 主服务器向多个从服务器发送更新，从服务器处理所有读请求

```
slaveof no one  // 该从服务器关闭复制功能，并从从服务器变回主服务器，数据不丢失，可以在主服务器失败的时候，将从属服务器用作新的主服务器，从而实现无间断运行
slaveof host post // 将当前服务器转变为指定服务器的从服务器
```

执行slaveof后的复制启动过程：

| 步骤 | 主服务器操作                                                 | 从服务器操作                                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | 等待命令进入                                                 | 连接或重连接主服务器，发送sync命令                           |
| 2    | 自动执行bgsave，并缓冲区记录bgsave之后执行的所有写命令       | 根据配置来决定是继续用现有数据处理客户端的命令请求，还是向客户端返回错误 |
| 3    | bgsave执行完毕，向从服务器发送快照文件，发送期间继续使用缓冲区记录 | 丢弃所有旧数据，开始使用快照                                 |
| 4    | 快照发送完毕，开始向从服务器发送缓冲区的写命令               | 完成对快照的解释操作，开始接受命令请求                       |
| 5    | 缓冲区写命令发送完毕。每执行一次写命令，就向从服务器发送相同的写命令 | 接收并执行主服务器传来的每个写命令                           |

**从服务器同步会清空数据**；**Redis不支持主主复制**

主从链：当读请求的重要性明显高于写请求，且读请求的数量远高于一台redis服务器可以处理的范围时，就需要添加新的从服务器，主服务器可能无法快速地更新所有从服务器，就需要建立**从服务器的从服务器**来分担主服务器的复制工作

### 优化

1. 缩短键值对的存储长度，必要时进行压缩
2. 设置键的过期时间
3. 使用Pipeline管道批量操作数据
4. 使用AOF，策略为每秒同步一次
   1. Master不要做持久化（快照写入对性能影响非常大，AOF文件过大会影响Master重启速度）
   2. 对某个Slave开启AOF备份，策略为每秒一次

### 分布式锁

最简单的setnx，为了保证原子性，能正确释放锁，使用lua脚本实现