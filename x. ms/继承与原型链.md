讲原型的时候，我们应该先要记住以下几个要点，这几个要点是理解原型的关键：

1. 所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）。

2. 所有的**引用类型**都有一个`_ _ proto_ _`属性(也叫隐式原型，它是一个普通的对象)。

3. 所有的**函数**都有一个`prototype`属性(这也叫显式原型，它也是一个普通的对象)。

4. 所有引用类型，它的`_ _ proto_ _`属性指向它的构造函数的`prototype`属性。

5. 当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的`_ _ proto_ _`属性(也就是它的构造函数的`prototype`属性)中去寻找。



![这里写图片描述](./media/70.png)

## 原型（对象属性）

Javascript规定，每一个函数都有一个prototype对象属性，指向另一个对象（原型链上面的）。
 prototype(对象属性)的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变(公用)的属性和方法，直接定义在prototype对象属性上。

prototype就是调用构造函数所创建的那个实例对象的原型。

prototype可以让所有对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中定义对象信息，而是可以直接将这些信息添加到原型中。

## 原型链

实例对象与原型之间的连接，叫做原型链。**proto**( 隐式连接 )

JS在创建对象的时候，都有proto属性，通过`__proto__`调用，用于指向创建它的函数对象的原型对象prototype。

内部原型(**proto**)和构造器的原型（prototype）
 1、每个对象都有一个**proto**属性,原型链上的对象正是依靠这个属性连结在一起
 2、作为一个对象，当你访问其中的一个属性或方法的时候，如果这个对象中没有这个  方法或属性，那么Javascript引擎将会访问这个对象的**proto**属性所指向上一个对 象，并在那个对象中查找指定的方法或属性，如果不能找到，那就会继续通过那个对象  的**proto**属性指向的对象进行向上查找，直到这个链表结束。

## constructor

在 Javascript 语言中，constructor 属性是专门为 function 而设计的，它存在于每一个 function 的prototype 属性中。这个 constructor 保存了指向 function 的一个引用。

### 

# 原文

当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为` __proto__ `）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。

几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。

尽管这种原型继承通常被认为是 JavaScript 的弱点之一，但是原型继承模型本身实际上比经典模型更强大。例如，在原型模型的基础上构建经典模型相当简单。

## 基于原型链的继承
### 继承属性
JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾

### 继承方法
JavaScript 并没有其他基于类的语言所定义的“方法”。在 JavaScript 里，任何函数都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别，包括上面的“属性遮蔽”（这种情况相当于其他语言的方法重写）

当继承的函数被调用时，this 指向的是当前继承的对象，而不是继承的函数所在的原型对象
