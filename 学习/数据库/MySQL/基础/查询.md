[TOC]

# 查询 SELECT

```sql
select * from tb1;
# 指定多个表
select * from tb1, tb2, tb3;

# 别名。给name设置别名n
select id, name n, cost from tb1;

# distinct去重，单独存在只能放在第一位，否则报错，
select distinct name from tb1;
# 和函数一起用可以随意放，计算不重复的记录
select id, count( distinct name ) from tb1;
# 用括号增加可读性
select distinct (name) from tb1;
# 表示name和cost同时不相等，distinct同时作用于两个字段
select distinct name, cost from tb1;
# 和上面相同，表示同时不相等
select distinct (name), cost from tb1;
# 报错，不能同时加括号
select distinct (name, cost) from tb1;
# 下面可以让distinct只作用于一个字段，并且需要多个数据。缺点是会多返回一个count字段。可使用group by，性能也高于distinct
select name, cost, count(distinct name) from tb1;
```

## WHERE
在where后使用**操作符**可设置查询条件

### 操作符
#### 比较操作符
`=`  `!=(<>)`  `<`  `>`  `<=` `>=`

#### 逻辑操作符：
1. IS NULL `where name is null`
2. BETWEEN 最大和最小之间的值，包含边界 `where cost between 20 and 30`
3. IN 是否和指定列表中的值匹配，比OR速度快 `where cost in(10, 20, 30)`
4. LIKE 使用通配符把一个值与类似的值进行比较。通配符%表示0、1或多个字符，_表示一个数字或字符，可复合使用
    
    ```sql
    # 以200开头的值
    where name like '200%';
    # 任意位置包含200的值
    where name like '%200%';
    # 第二和第三个字符是0的值
    where name like '_00%';
    # 以2开头，长度至少为3的值
    where name like '2_%_%';
    # 以2为结尾的值
    where name like '%2';
    # 第二个位置为2，结尾为3的值
    where name like '_2%3';
    # 长度为5，以2开头，以3结尾
    where name like '2___3';
    ```
5. EXISTS 是否存在满足条件的记录

    ```sql
    select cost from tb1 
    where exists (select cost from cost where cost>100);
    ```

6. UNIQUE
7. ALL, ANY(SOME)
    ALL：把一个值与另一个集合里的全部值进行比较
    SOME是ANY的别名，用于把一个值与另一个列表里人一直进行比较
    
    ```
    # 测试cost大于tb1里所有数据的cost
    where cost > all cost (select from tb1);
    ```

#### 连接操作符
组合多个条件，连接多个操作符

1. AND 所有条件都为true，SQL语句才会执行 `where id='1' and name='2'`
2. OR 至少有一个是true，就会执行

#### 求反操作符

1. <>, !=
2. NOT BETWEEN 不处于范围之内
3. NOT IN 不在列表里
4. NOT LIKE 不相似
5. IS NOT NULL 不是NULL
6. NOT EXISTS 不在表里
7. NOT UNIQUE

#### 算数操作符
执行算数功能 + - * /

```
# 输出的列名为cost*2，结果是cost*2的值
select cost*2 from tb1;

select * from tb1 where cost*2 > 10;
select * from tb1 where cost + num > 10;
```

### 子查询（嵌套查询）
位于where子句里的查询。它返回的数据在主查询里作为一个条件，进一步限制数据库返回的数据。子查询会影响效率

**规则**
* 操作符和主查询相同
* 必须位于圆括号内
* 不能使用order by，可以使用group by来实现order by的功能
* 除非主查询里有多个字段让子查询进行比较，否则子查询的SELECT子句里只能有一个字段
* 返回多条记录的子查询只能与多值操作符（比如IN）配合使用
* SELECT列表里不能引用任何BLOB、ARRAY、CLOB或NCLOB类型的值
* 不能直接被包在函数里
* 操作符between不能用于子查询（不能在子查询外部使用between），但子查询内部可以使用它
* 子查询可以嵌套子查询，先从最内层的开始查询

```sql
select * from tb1 where cost > (select cost from tb2 where id='111');
# 子查询得到一个用“=”，得到多个用“in”
# some/any()：只要有一个匹配，就返回。查询最低的cost：
select * from tb1 where cost > some (select cost from tb1);
# all()：必须全部匹配
select * from tb1 where cost >= all(select cost from tb1);
# exists() 是否存在结果，返回true/false
select * from tb1 where (not) exists (select * from tb1 where id='111');
```

## ORDER BY
默认升序ASC（字母顺序A-Z | 0-9），基于ascii排序。反字母顺序DESC

```sql
select * from tb1 order by name asc; 

# order by后面的数组表示select之后列的位置，从1开始。下面为按name排序
select id, name, cost from tb1 order by 2;
# 可对多个字段进行排序。首先对id排序，然后对cost，最后对name
select id, name, cost from tb1 order by 1, 3, 2;
```

## 组合查询（复杂查询）
处理多个select的结果
### 并集 UNION
用第二个查询结果合并第一个查询结果
union前后select字段数量必须相同
UNION不显示两个查询中的重复的行。`UNION ALL`显示所有行（包括重复行）
可以使用多个union

```sql
select id, name, aa from tb1
union
select id, desc, bb AS aa from tb2;

# 所有select只能有一个order by，因为返回一个结果
order by 1
# 所有select中都存在的字段可以在order by中使用该字段
order by id
# 并非都存在的字段，可以设置别名让他们的字段名都相同，就可以使用order by对其进行排序了
order by aa

# group by和order by的规则相同
```

### 交集 INTERSECT
mysql不支持

### 叉 EXCEPT
第一个集合有， 第二个没有
mysql不支持