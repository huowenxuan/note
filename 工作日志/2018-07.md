------

## 7.4 
### -10.52 
决定把PropTypes改为FlowTypes，虽然原则是明明不和使用技术挂钩，单它本来也是为Flow准备的，而且type关键字也是flow提供的，将来也不大可能使用别的库，唯一的可能就是转为TypeScript，到时候改动太大，改一个文件也是顺手的事

### -13.38 
终于解决了循环依赖的问题。多次循环依赖导致各种奇怪的问题，奇怪的报错

先查看react-native源码中index文件的导出方式

```
module.exports = {
  get AccessibilityInfo() { return require('AccessibilityInfo'); },
  get ActivityIndicator() { return require('ActivityIndicator'); },
  get ART() { return require('ReactNativeART'); },
  get Button() { return require('Button'); },
  ...
};
```

和我们平时错误的写法不一样：

```
import AccessibilityInfo from 'AccessibilityInfo'
import ActivityIndicator from 'ActivityIndicator'
import ReactNativeART from 'ReactNativeART'
import Button from 'Button'

module.exports = {
	AccessibilityInfo,
	ActivityIndicator,
	ReactNativeART,
	Button
};
```

!!!重点不是get方法，而是先导出自身，再导入其他模块，也就是在export之外（不管是前后）没有任何import/require，在index.js这种文件中**只有module.exports**，如果想做其他判断等操作，可以写在get方法中

require是延迟执行，用到才会执行里面的代码，所以对于某些需要导入立刻执行的模块，还是需要import，应该避免这种情况发生。例外：Overlay的TopView，需要导入后自动调用AppRegistry.registerComponent，因为对AppRegistry.registerComponent进行了改写，需要尽早执行

**用require引用export default导出的组件，要使用require().default**









### -15.7 
把dva的创建从App.js移动到models/index中，可直接引入store，方便多个文件使用到store的情况

将models/index的module.export改为expot const store + export const types，否则在TopView中improt到的值为空

再次复习一遍ES6模块、CommonJS

1. CommonJS 模块输出的是一个值的拷贝，一点输出，模块内部的变化就影响不到这个值
2. ES6 模块输出的是值的引用，遇到import，会生成一个只读引用，等到脚本真正执行，再根据这个只读引用，到被加载的那个模块中取值，原始值变了。import加载的值也会变
3. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。因为CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
4. exports = module.exports
5. import加载module.exports，等同于export default。
6. 循环引用：CommonJS在循环引用时如果值发生改变，会导致两处引用同一文件的值不同。ES6模块循环引用会导致其中一个模块引用变量获取不到值，解决方法是导出时把变量改为函数，因为函数可以提升

```
let a = 1;
export a; // 错误，导出了1
export {a}; // 正确
export let a = 1; // 正确
```

### -15.16 
没再遇到循环引用的问题，无法验证，下面三种方式需要下次再遇到时验证

1.

```
module.exports = {
  get Alert() {
    return require('./Alert').default
  },
  get HOC() {
    return require('./HOC')
  },
  get Loading() {
    return require('./Loading').default
  },
  get CustomSS() {
    return require('./CustomStyleSheet')
  },
  get FlowTypes() {
    return require('./FlowTypes')
  },
}
```

2.

```
import Alert from './Alert'
import * as HOC from './HOC'
import Loading from './Loading'
import CustomSS from './CustomStyleSheet'
import * as FlowTypes from './FlowTypes'

module.exports = {
  Alert,
  HOC,
  Loading,
  CustomSS,
  FlowTypes
}
```

3.

```
import Alert from './Alert'
import * as HOC from './HOC'
import Loading from './Loading'
import CustomSS from './CustomStyleSheet'
import * as FlowTypes from './FlowTypes'

export {
  Alert,
  HOC,
  Loading,
  CustomSS,
  FlowTypes
}
```










### -16.6 
优化Overlay的调用方式，之前的TODO想用高阶组件实现，不可以，是反向的，直接继承即可，并且不需要再实现willMount和unmount，通过传参自定义显示动画也没必要，代码更乱

flow声明数组类型：`imgs: string[]`，或者`imgs: Array<string>`

关于在组件中声明props类型，使用flow的type还是react的propTypes，网上有很多比较，type是编码时的检查，propTypes是运行时的检查，应该都是必要的，虽然会导致代码重复

### -18.32 
研究第三方库，react-native-lottie是Airbnb开源的动画组件，在AE上制作的动画，通过一个插件导出json格式就可以在RN中使用，不会AE所以没办法用。react-native-animatable提供了很多动画效果

引入了一些旧的公共组件

参考ionc的alert、loading等组件，重新设计Overlay的创建和消失方法，不再公开Overlay的全部消失或者从顶层消失的方法，容易造成流程和代码混乱。把hide方法改成dismiss。有两种使用方法：

1. 每个Overlay都需要使用new新建实例，当显示时调用实例show方法，消失时调用实例的dismiss方法。不可以更新，如果要连续显示多个，需要先dismiss再新建（更新是个问题）
    
    ```
    let loading = new Loading('加载中...')
    loading.show()
    loading.dismiss()
    ```

2. Overlay新增type参数，可通过type来使Overlay消失。可直接调用Overlay组件的静态show和dismiss方法来快捷创建和消失

    ```
    Loading.show('加载中')
    // 让所有的Loading消失，调用dismissOverlayWithType方法
    Loading.dismiss()
    ```


### TODO
还需要重构Overlay，按照今天的思路修改底层逻辑，支持数据的更新

------

## 7.3 
### -11.34  
dva的回调和错误处理完成。自己实现了结果回调，然后想怎么处理错误就怎么处理。确定了API的调用方式，直接在effects中调用，能方便的进行错误判断，不需要创建双倍的文件，而不会多余一行代码

```
// HOC 中重新封装dispatch，返回一个promise对象，并把这个promise的resolve和reject传给dva，进行流程控制
dispatch: (type, payload) => {
   return new Promise((resolve, reject)=>{
    dispatch(createAction(type)(payload, resolve, reject))
  })
}

// model的effects
* [types.login]({payloa, resolve, reject}, {call, put}) {
  let {error, data} = yield call(post, '/login')  
  if (error) {
    reject(error)  
  } else {
    resolve(data)
    yield put(createAction(types.updateState)({auth: data}))
  }
}

// Components中进行流程控制（优化前的dva是不能进行流程控制的）：
try {
  let payload1 = await dispatch(types1, {})
  let payload2 = await dispatch(types2, {})
  let payload3 = await dispatch(types3, {})
} catch(e) {
}

// 老项目中redux-actions + redux-promise + redux-thunk配合的使用，繁琐了很多，而且不够先进
let {payload: payload1, error: error1} = await dispatch(types1, {})
let {payload: payload1, error: error2} = await dispatch(types1, {})
let {payload: payload1, error: error3} = await dispatch(types1, {})
```

修改网络请求的返回数据

```
// 以前的写法
try {
  return (await axios(config)).data
} catch (e) {
  return {error: _handleError(e, config)}
}

// 优化
try {
  return {data: (await axios(config)).data}
} catch (e) {
  return {error: _handleError(e, config)}
}

// 区别显而易见
// 修改前
let response = await get(...)
let data =  response
let error = response.error

// 修改后
let {data, error} = await get(...)
```






### -12.0 
受angular依赖注入的启发，把toast也当做props，放在HOC中传给container使用，可以直接用this.props.toast.show()来显示toast，不需要再次import Toast了



### -13.26 
再次重新设计Overlay，按照react组件的方式进行封装，需要哪个导入哪个，直接调用，而不是通过router调用，本来和router就没有关系




### 13.30-15.15 
开会

### -18.38 
重新设计组件的方式，老项目中每个组件都需要引入半页的子组件受够了

```
components 
--common
----index
----CustomStyleSheet
----HOC
----ActionSheet
----PropTypes
----Loading
----Toast
----OpacityButton
----Overlay
------index
------OverlayFade
--Topic
----index
----TopicRow
```

> 1. 把所有的Overlay、StyleSheet、HOC都放在common中，其实是参考了react源码的设计，把所有组件、API都放在一起，可以统一引入
2. Overlay只放Overlay方法和动画，要显示的Overlay组件还是放在common中

分模块导入，而不是分文件导入，节省了很多行代码

```
import {HOC, Alert, OpacityButton, PropTypes} from '../components/common'
import {TopicRow} from '../components/Topic'

// 对于组件的影响
type Props = PropTypes.Contaienr & {}
@HOC.container()
```

在Overlay的一个动画中引入StyleSheet导致重复引用搞了好久，common中的组件使用了Overlay，而Overlay中的一个动画又使用了common中的一个组件，最后还是通过相对路径导入来解决的，在其他文件中没有这样的问题：1）common中的组件互相引用的情况不多，直接import相对路径即可，而且将来移动位置，导入到其他工程可以不做一点改动。2）业务组件导入common正常，common导入业务组件的情况不可能发生

```
// 循环引用的解决方法
import {CustomSS} from '../common' // 错误
import CustomSS from '../common/CustomStyleSheet' // 正确
```

### TODO
1. Overlay组件支持配置自定义的进场出场动画
2. Overlay动画使用HOC来实现
3. PropTypes需要重命名，因为和react的PropTypes重名了，想不出来合适的

------

## 7.2 
### -11.50 
### 使用flow

1. 安装时候不能使用brew，会卡住，使用npm install flow-bin -g
2. 终端输入flow运行，但是报错版本不对。RN中默认生成了.flowconfig文件，并且指定了一个低版本的flow，修改[version]下面的版本号即可
3. 在每个需要检查的文件最上方加入`//@flow`或者`/*@flow*/`，或者给某个类、变量标注`//@flow`即可进行检查

### flow自带一个变量type，用于声明对象或者类的类型

```
type Prop = {}
type State = {}
class App extends PureComponent<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = {
    }
  }
}
```

### 忽略node_modules
.flowconfig

```
[ignore]
.*/node_modules/.*
```

### 运行提示react-native、redux等库找不到

```
// 需要VPN
yarn global add flow-typed
flow-typed install
```

修改后没好，重启下电脑就好了？

### @connect警告，忽略decorators
flow警告这还是一个提案，在.flowconfig忽略它，等号左右不能有空格

```
[optioins]
esproposal.decorators=ignore
```








### -15.35 
因为container需要props包含types、dispatch、router等固定props，而在每个container中都重复写一遍是很不明智的，而每个container都有各自单独的props，找到了一种办法可以合并不同的type


```
type ContaienrProps = {
  dispatch: mixed,
  types: mixed,
  router: Router
}

type Props = {
   id: string
}

class App extends PureComponent<ContainerProps & Props> {
  constructor(props: ContainerProps & Props) {
      super(props)
  }
}
```

上面的写法在constructor中比较繁琐，而且重复了，优化：

```
type ContaienrProps = {
  dispatch: mixed,
  types: mixed,
  router: Router
}

type Props = ContaienrProps & {
   id: string
}

class App extends PureComponent<Props> {
  constructor(props: Props) {
      super(props)
  }
}
```

封装在一个文件中：

```
PropTypes.js
export type ContainerProps = {
  dispatch: any, // 官方推荐能用mixed就不用any，但是在这个文件中使用mixed会报错，any就没有问题，需要再研究
  types: any,
  router: Router
}


// 导入
import type {ContainerProps} from '../utils/PropTypes'
```

dva的model.js不用flow，因为类型比较灵活，使用flow反而难以管理，处理数据的代码也会不整洁，flow现阶段只用来处理组件

至此，flow类型检查的错误全部修复




### -17.34 
手贱mac升级到10.14beta，一不操作电脑就死机

使用OC实现了一个mac小应用暂时避免这个问题。先实现循环模拟鼠标左键点击（经测试，只是鼠标没用。可以在外出时电脑后台开启），还需要今天和明天测试，因为上午和中午崩溃的次数较多，三四点以后几乎不崩溃，如果管用。明天再加强功能：监听鼠标的点击，如果20秒内没有点击，就开始模拟点击

> pyhook只支持windows，pyautogui需要quartz，quartz安装失败。node不能实现全局监听，只能监听程序本身的键盘输入。最后只能用mac原生实现

### -18.31 
接入登录API

1. 研究dva的回调和错误处理，dva的effects本身不支持返回promise来获取结果，一个大坑，需要自己实现结果回调，比较简单的是在dispatch最后添加一个参数onComplete，但是不喜欢回调的方式，想在creatAction中统一返回一个promise，错误处理也可以自己来控制
2. 探究更好的API调用方式（统一写在services/下还是直接放在models/中）

