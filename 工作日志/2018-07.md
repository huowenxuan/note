------

## 7.3 
### -11.34 
dva的回调和错误处理完成。自己实现了结果回调，然后想怎么处理错误就怎么处理。确定了API的调用方式，直接在effects中调用，能方便的进行错误判断，不需要创建双倍的文件，而不会多余一行代码

```
// HOC 中重新封装dispatch，返回一个promise对象，并把这个promise的resolve和reject传给dva，进行流程控制
dispatch: (type, payload) => {
   return new Promise((resolve, reject)=>{
    dispatch(createAction(type)(payload, resolve, reject))
  })
}

// model的effects
* [types.login]({payloa, resolve, reject}, {call, put}) {
  let {error, data} = yield call(post, '/login')  
  if (error) {
    reject(error)  
  } else {
    resolve(data)
    yield put(createAction(types.updateState)({auth: data}))
  }
}

// Components中进行流程控制（优化前的dva是不能进行流程控制的）：
try {
  let payload1 = await dispatch(types1, {})
  let payload2 = await dispatch(types2, {})
  let payload3 = await dispatch(types3, {})
} catch(e) {
}

// 老项目中redux-actions + redux-promise + redux-thunk配合的使用，繁琐了很多，而且不够先进
let {payload: payload1, error: error1} = await dispatch(types1, {})
let {payload: payload1, error: error2} = await dispatch(types1, {})
let {payload: payload1, error: error3} = await dispatch(types1, {})
```

修改网络请求的返回数据

```
// 以前的写法
try {
  return (await axios(config)).data
} catch (e) {
  return {error: _handleError(e, config)}
}

// 优化
try {
  return {data: (await axios(config)).data}
} catch (e) {
  return {error: _handleError(e, config)}
}

// 区别显而易见
// 修改前
let response = await get(...)
let data =  response
let error = response.error

// 修改后
let {data, error} = await get(...)
```






### -12.0 
受angular依赖注入的启发，把toast也当做props，放在HOC中传给container使用，可以直接用this.props.toast.show()来显示toast，不需要再次import Toast了



### -13.26 
再次重新设计Overlay，按照react组件的方式进行封装，需要哪个导入哪个，直接调用，而不是通过router调用，本来和router就没有关系




### 13.30-15.15 
开会

### -18.38 
重新设计组件的方式，老项目中每个组件都需要引入半页的子组件受够了

```
components 
--common
----index
----CustomStyleSheet
----HOC
----ActionSheet
----PropTypes
----Loading
----Toast
----OpacityButton
----Overlay
------index
------OverlayFade
--Topic
----index
----TopicRow
```

> 1. 把所有的Overlay、StyleSheet、HOC都放在common中，其实是参考了react源码的设计，把所有组件、API都放在一起，可以统一引入
2. Overlay只放Overlay方法和动画，要显示的Overlay组件还是放在common中

分模块导入，而不是分文件导入，节省了很多行代码

```
import {HOC, Alert, OpacityButton, PropTypes} from '../components/common'
import {TopicRow} from '../components/Topic'

// 对于组件的影响
type Props = PropTypes.Contaienr & {}
@HOC.container()
```

在Overlay的一个动画中引入StyleSheet导致重复引用搞了好久，common中的组件使用了Overlay，而Overlay中的一个动画又使用了common中的一个组件，最后还是通过相对路径导入来解决的，在其他文件中没有这样的问题：1）common中的组件互相引用的情况不多，直接import相对路径即可，而且将来移动位置，导入到其他工程可以不做一点改动。2）业务组件导入common正常，common导入业务组件的情况不可能发生

```
// 循环引用的解决方法
import {CustomSS} from '../common' // 错误
import CustomSS from '../common/CustomStyleSheet' // 正确
```

### TODO
1. Overlay组件支持配置自定义的进场出场动画
2. Overlay动画使用HOC来实现
3. PropTypes需要重命名，因为和react的PropTypes重名了，想不出来合适的

------

## 7.2 
### -11.50 
### 使用flow

1. 安装时候不能使用brew，会卡住，使用npm install flow-bin -g
2. 终端输入flow运行，但是报错版本不对。RN中默认生成了.flowconfig文件，并且指定了一个低版本的flow，修改[version]下面的版本号即可
3. 在每个需要检查的文件最上方加入`//@flow`或者`/*@flow*/`，或者给某个类、变量标注`//@flow`即可进行检查

### flow自带一个变量type，用于声明对象或者类的类型

```
type Prop = {}
type State = {}
class App extends PureComponent<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = {
    }
  }
}
```

### 忽略node_modules
.flowconfig

```
[ignore]
.*/node_modules/.*
```

### 运行提示react-native、redux等库找不到

```
// 需要VPN
yarn global add flow-typed
flow-typed install
```

修改后没好，重启下电脑就好了？

### @connect警告，忽略decorators
flow警告这还是一个提案，在.flowconfig忽略它，等号左右不能有空格

```
[optioins]
esproposal.decorators=ignore
```








### -15.35 
因为container需要props包含types、dispatch、router等固定props，而在每个container中都重复写一遍是很不明智的，而每个container都有各自单独的props，找到了一种办法可以合并不同的type


```
type ContaienrProps = {
  dispatch: mixed,
  types: mixed,
  router: Router
}

type Props = {
   id: string
}

class App extends PureComponent<ContainerProps & Props> {
  constructor(props: ContainerProps & Props) {
      super(props)
  }
}
```

上面的写法在constructor中比较繁琐，而且重复了，优化：

```
type ContaienrProps = {
  dispatch: mixed,
  types: mixed,
  router: Router
}

type Props = ContaienrProps & {
   id: string
}

class App extends PureComponent<Props> {
  constructor(props: Props) {
      super(props)
  }
}
```

封装在一个文件中：

```
PropTypes.js
export type ContainerProps = {
  dispatch: any, // 官方推荐能用mixed就不用any，但是在这个文件中使用mixed会报错，any就没有问题，需要再研究
  types: any,
  router: Router
}


// 导入
import type {ContainerProps} from '../utils/PropTypes'
```

dva的model.js不用flow，因为类型比较灵活，使用flow反而难以管理，处理数据的代码也会不整洁，flow现阶段只用来处理组件

至此，flow类型检查的错误全部修复




### -17.34 
手贱mac升级到10.14beta，一不操作电脑就死机

使用OC实现了一个mac小应用暂时避免这个问题。先实现循环模拟鼠标左键点击（经测试，只是鼠标没用。可以在外出时电脑后台开启），还需要今天和明天测试，因为上午和中午崩溃的次数较多，三四点以后几乎不崩溃，如果管用。明天再加强功能：监听鼠标的点击，如果20秒内没有点击，就开始模拟点击

> pyhook只支持windows，pyautogui需要quartz，quartz安装失败。node不能实现全局监听，只能监听程序本身的键盘输入。最后只能用mac原生实现

### -18.31 
接入登录API

1. 研究dva的回调和错误处理，dva的effects本身不支持返回promise来获取结果，一个大坑，需要自己实现结果回调，比较简单的是在dispatch最后添加一个参数onComplete，但是不喜欢回调的方式，想在creatAction中统一返回一个promise，错误处理也可以自己来控制
2. 探究更好的API调用方式（统一写在services/下还是直接放在models/中）

