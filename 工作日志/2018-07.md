------

## 7.12 
### -16.56 
研究高德地图自定义线路规划

一直运行不起来，遇到了几个问题

更新了Xcode，需要更新pod

```
sudo gem install cocoapods --pre -n /usr/local/bin
```

编译报错`library not found for -lstdc++.6.0.9`，需要第三方的支持，已提交工单，暂时的解决办法：

1. 下载libstdc++： https://raw.githubusercontent.com/luapower/libstdcxx/master/bin/linux64/libstdc%2B%2B.a 
2. 解压，复制`/libstdcxx-master/bin/linux64/libstdc++.a`到Xcode的Frameworks中，重命名为`libstdc++.6.0.9.a`，确保Link Binary With Libraries中也添加上这个文件
3. 再次运行，编译通过

高德地图线路规划的顺序为：

1. 添加开始点和结束点，调用线路规划API获取线路数据
2. 在结果回调中根据结果自己绘制线路、开始实时导航，这是两个操作

调用API进行线路规划也是要自己绘制的，文档中并没有写自定义的线路规划，所以可以自己来写线路，然后让高德进行规划

### -18.23 
没有找到高德地图根据自定义的坐标来导航的方法

要使用实时导航，还需要添加导航界面AMapNaviDriveView，在线路规划是不需要的，自定义线路只需要根据位置实时更新折线就可以了


------

## 7.11 
### 10.50-11.54 
学习使用日历组件

### -13.20 
使用uiautomator实现android版微信读书自动翻页工具，上传到github

### -14.23 
找RN的图标组件

react-native-chart 1400star， 不再更新
react-native-echart 400 star，是WebView加载echarts，性能不怎么样
victory-native 1000 star，react-native-chart作者推荐使用

### -16.23 
学习victory-native画图表，它是基于victory的rn版，支持victory所有功能。victory是基于React的一个图表库，6000+star

支持各种类型的图表，刷新数据后可以通过动画更新图表

VictoryLine设置animate后不显示图像，需要增加参数`groupComponent={<G/>}`，G来源于react-native-svg

设置labels回调可以添加文字，如果设置了动画，文字也是渐变

### -18.15 
学习native-base和react-native-elements组件库，阅读源码，学习一些好的解决方案

参考游云南、其他一些小程序的功能


------

## 7.10 
### -13.0 
实现新的下拉刷新动画。参考即刻app，下拉、刷新中、释放的状态都不一样

解压即刻apk、ipa，ipa只能从app store下载，也可以下载PP助手电脑版下载发，github上有两个相关的程序：

* [获取到PP助手的ipa链接并且下载](https://github.com/ytx0574/IPASearch)
* [获取ipa、car文件中的图片](https://github.com/devcxm/iOS-Images-Extractor#build)

### 14.30-16.20 
开会

### -17.42 
RN新版对TextInput有较大的改动，以前如果手动设置value，就是让用户自己来管理输入内容，同时要必须在onChangeText里手动setState来修改value才能让输入生效。新版本让onChangeText来返回修改后的结果，在输入时就已经把值赋好了。旧版本的输入框设置maxLength后超出会导致闪烁，也是输入和setState不同步导致，新版本从源头解决了这个问题。

这样做的好处很多，显示及时，提升了用户体验，以前的输入是有延迟的，这是不可理喻的，同时也避免了很多之前遇到的无法解决的bug，如输入特别卡顿、输入太快会不生效。

在旧版本时，为了避免maxLength的闪烁问题，自己实现了限制长度的输入框，原理就是通过onChangeText来判断输入的长度，进行截断，可以达到目的，但是有bug：使用输入中文时会导致拼音也无法超出最大值，所以拼音无法输入完整。

新版的TextInput设置了maxLength后，有以下两个问题：

1. 设置maxLength后，使用iOS自带的中文输入法，如果拼音超出maxLength，拼音会被截断，无法继续输入，并不是每次都发生，没找到规律，只能等官方解决
2. 无法通过`中文占2字符，英文占1字符`来限制输入的长度。由于无法拦截onChangeText（如果强行在这个回调里setState，会导致输入的拼音被打断）

RN的输入框是实现的最恶心的组件，普通用还好，如果要对功能进行定制，永远都有新的问题

### -18.37 
加入日历组件 react-native-calendars


------

## 7.9 
### -11.37 
查看鹿小圈不能下载文件的问题，在多个机型都没有发现，使用华为真机测试，所有设备都不能联网，没办法测试。先把腾讯浏览服务TBS从一年前的3.2.0升级到上个月的3.6.0，可以正常运行

iOS的图片选择器去掉拍照功能，点击拍照会闪退，第三方库的问题

push鹿小圈代码，因为是后来新建后转移的项目，所以不能直接push，需要把旧代码pull到一个新的地方，在全部替换后push

### -14.12 
研究Facebook的App自动化测试库WebDriverAgent、python-wda，特别简单，可以输出屏幕组件信息，模拟任何app的手势和键盘、根据参数找屏幕的element。最后用十分钟时间做出了一个微信读书自动翻页的工具

> 适合iOS使用，android使用uiautomator

### 安装WebDriverAgent
1. git clone https://github.com/facebook/WebDriverAgent.git
2. ./Scripts/bootstrap.sh
3. 打开`WebDriverAgent.xcodeproj`，设置好开发者apple id
4. Product -> **Test**，在手机上运行，打开一下会自动关闭，然后在Xcode控制台输出ServerURL: http://x.x.x.x:8100
5. brew install imobiledevice
6. iproxy 8100 8100，到`http://localhost:8100/status`就可以正常访问了

### python-wda
pip3 install python-wda

```python
import wda

wda.DEBUG = False
wda.HTTP_TIMEOUT = 60.0

c = wda.Client('http://localhost:8100')
print(c.status())

# 按下home键
# c.home()

# 保存截图
# c.screenshot('screen.png')

# 输出全屏显示内容，accessible为True为JSON，False为XML
# print(c.source(accessible=True))

# 打开app
s = c.session('com.tencent.weread')

# 屏幕尺寸
print(s.window_size()) # Size(width=414, height=736)

'''
s.tap(200, 600) # 单击
s.double_tap(200, 600) # 双击
s.swipe(x1, y1, x2, y2, 0.5) # 0.5s 扫
s.tap_hold(x, y, 1.0) # 长按 1秒
'''

'''
根据条件找element
s(id="URL").exists
s(id='URL')
s(name='URL')
'''

import threading
import random

def toFixed(num, ndigits=2):
    return round(num, ndigits)

def fun_timer():
    # 随机点击坐标
    x = random.randint(300, 400)
    y = random.randint(400, 700)
    s.tap(x, y)
    global timer
    # 随机时间，正常阅读一页的时间为12-30秒
    second = random.uniform(12, 30)
    timer = threading.Timer(second, fun_timer)
    print('点击的坐标为(' + str(toFixed(x)) + ', ' + str(toFixed(y)) + '), ' + str(toFixed(second)) + '秒后再次点击')
    timer.start()

# 打开3秒后开始循环
timer = threading.Timer(3, fun_timer)
timer.start()
```

### -15.19 
打包鹿小圈，发布都所有平台

### -16.22 
在Xcode10上运行新旧项目

> 因为手机升级到iOS 11，必须使用Xcode10才能让程序运行在手机上，而电脑的剩余硬盘不足1G，只能保留一个Xcode，所以兼容Xcode10

1. 报错`Build input file cannot be found: '/.../node_modules/react-native/Libraries/WebSocket/libfishhook.a'`
Xcode中Libraries->RCTWebSocket->TARGETS RCTWebSocket->BuildPhases->Link Binary With Libraries->删掉libfishhook.a再重新导入
2. 报错`That command depends on command in Target : script phase “[CP] Copy Pods Resources”`
Xcode中File->Workspace Settings->Build System改为Legacy Build System
3. 报错`library not found for -lstdc++.6.0.9`
libstdc++几年前就被废弃，在Xcode10中正式被删除，用libc++代替即可

### -17.49 
实现图片的渐变加载：[Progressive image loading in React Native
](https://medium.com/the-react-native-log/progressive-image-loading-in-react-native-ecc88e724343)，原理就是先加载一张模糊的缩略图，等大图加载出来后再加载大图，隐藏缩略图。经过修改，实现了先加载一张本地展位图，再渐现加载大图

### -18.33 
研究android自动化测试框架uiautomator，和wpa使用方法基本一样


------

## 7.6 
### -11.17 
把arguments改为...rest，arguments已经废弃

使用react-native-animatable写动画，支持useNativeDriver原生优化。不准备重写Overlay的动画，Overlay是一个单独的模块，不能加太多依赖

### -15.18 
实现自ListView定义下拉刷新动画，fork react-native-pull自己修改，作者已不再更新。原理是用手势实现下拉刷新，覆盖掉RN的refreshControl组件，并且支持通过回调来结束刷新，比通过state来修改更方便进行流程控制，代码也更简洁。**支持Andorid**，android甚至都没有下拉刷新

### -16.29 
重构下拉刷新组件，精简多余代码

1. 去掉多余的props，不需要太多的自定义。
2. 添加回弹动画，使用ease动画代替生硬的linear动画，回弹的时间缩短
3. 下拉的实际距离等于下拉距离除以3，可以模拟下拉的阻力效果，像原生效果
4. 可任意配置GIF动画了

第一次在Android上运行、测试，没有问题

> Genymotion在新版mac无法运行，不兼容，需要作者更新



### -17.45 
之前的模拟下拉的阻力效果，并不太像原生，原生拉到3/4基本就拉不下去了，阻力是逐渐加大的，想实现这样的算法没有成功。其实插值动画更适合，但是手势不能用插值动画。

手势gesture的几个参数

* x0, y0: 手势开始时的点相对于全屏的坐标
* dx, dy: 当前点相对于开始点的坐标，移动了多远
* moveX, moveY: 当前点相对于全屏的坐标


------

## 7.5 
### -12.7 
优化OverlayView的更新，以loading为例，可以方便的更新显示内容，核心还是通过ref来更新状态，如果是Overlay内部要自动消失，需要传dismiss方法

```
let loading  = new Loading()
loading.show('1')
// 更新
loading.show('2')
loading.dismiss()

Loading.show('1')
Loading.show('2')
Loading.dismiss()
```

昨晚Facebook发布了RN 0.56.0 release版，还是不能更新，因为没有解决修饰器的问题

1.`?.`
2. 提到了他们正在远离PropTypes和运行时检查，更多的依赖于Flow，正好是昨天研究的内容。专门为Flow添加了所有的组件类型
3. Android终于支持了Image.defaultSource
4. underlineColorAndroid默认为透明了，以前直接创建的Android输入框默认都会下黑色的下划线，需要手动隐藏掉，现在可以免去这一操作

### -16.3 
引入dayjs，国人做的只有2kb大小的时间处理库，可以代替200k+的moment

再次重新设计overlay，功能完善，节省了大量打码，更易于创建。
> 新建一个OverlayComponet组件作为所有Overlay的基类，里面有更新state的方法，不需要在每个Overlay中再实现一遍，实现overlayComponent高阶函数，将每个Overlay组件转换为模块，可以指定动画模块，里面有show、dismiss方法，其中每调用一次show都会执行update来更新组件，而不是新建组件

为overlayComponent封装argsRest2Obj方法作为必要参数，可进行参数类型的转换，不同的Overlay进行不同的转换

```
// 转换
function argsRest2Obj(text, sec) {
    return {text, sec}
}

// 使用
// 旧的传参
Toast.show({text: "OK", sec: 2})
// 新的传参
Toast.show('OK', 2)
```

加入足够多的注释

### -18.33
使用新设计的Overlay移植多个覆盖物组件（都需要设计样式）：

* Loading
* Toast
* ActionSheet

Alert不再自己封装，封装RN的Alert。以前不使用是因为和Modal配合会导致崩溃，现在程序中没有Modal了就可以使用原生的了，在Android上显示会更像一个原生程序，或者将来有新的设计可以再改

引入多个全局style

学习react-native-animatable，是一个较完善的RN动画库，但是还是基于Animated、Easing来实现的，只是效果比较多，并没有提升性能，RN的动画效果太差了


------

## 7.4 
### -10.52 
决定把PropTypes改为FlowTypes，虽然原则是明明不和使用技术挂钩，单它本来也是为Flow准备的，而且type关键字也是flow提供的，将来也不大可能使用别的库，唯一的可能就是转为TypeScript，到时候改动太大，改一个文件也是顺手的事

### -13.38 
终于解决了循环依赖的问题。多次循环依赖导致各种奇怪的问题，奇怪的报错

先查看react-native源码中index文件的导出方式

```
module.exports = {
  get AccessibilityInfo() { return require('AccessibilityInfo'); },
  get ActivityIndicator() { return require('ActivityIndicator'); },
  get ART() { return require('ReactNativeART'); },
  get Button() { return require('Button'); },
  ...
};
```

和我们平时错误的写法不一样：

```
import AccessibilityInfo from 'AccessibilityInfo'
import ActivityIndicator from 'ActivityIndicator'
import ReactNativeART from 'ReactNativeART'
import Button from 'Button'

module.exports = {
	AccessibilityInfo,
	ActivityIndicator,
	ReactNativeART,
	Button
};
```

!!!重点不是get方法，而是先导出自身，再导入其他模块，也就是在export之外（不管是前后）没有任何import/require，在index.js这种文件中**只有module.exports**，如果想做其他判断等操作，可以写在get方法中

require是延迟执行，用到才会执行里面的代码，所以对于某些需要导入立刻执行的模块，还是需要import，应该避免这种情况发生。例外：Overlay的TopView，需要导入后自动调用AppRegistry.registerComponent，因为对AppRegistry.registerComponent进行了改写，需要尽早执行

**用require引用export default导出的组件，要使用require().default**









### -15.7 
把dva的创建从App.js移动到models/index中，可直接引入store，方便多个文件使用到store的情况

将models/index的module.export改为expot const store + export const types，否则在TopView中improt到的值为空

再次复习一遍ES6模块、CommonJS

1. CommonJS 模块输出的是一个值的拷贝，一点输出，模块内部的变化就影响不到这个值
2. ES6 模块输出的是值的引用，遇到import，会生成一个只读引用，等到脚本真正执行，再根据这个只读引用，到被加载的那个模块中取值，原始值变了。import加载的值也会变
3. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。因为CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
4. exports = module.exports
5. import加载module.exports，等同于export default。
6. 循环引用：CommonJS在循环引用时如果值发生改变，会导致两处引用同一文件的值不同。ES6模块循环引用会导致其中一个模块引用变量获取不到值，解决方法是导出时把变量改为函数，因为函数可以提升

```
let a = 1;
export a; // 错误，导出了1
export {a}; // 正确
export let a = 1; // 正确
```

### -15.16 
没再遇到循环引用的问题，无法验证，下面三种方式需要下次再遇到时验证

1.

```
module.exports = {
  get Alert() {
    return require('./Alert').default
  },
  get HOC() {
    return require('./HOC')
  },
  get Loading() {
    return require('./Loading').default
  },
  get CustomSS() {
    return require('./CustomStyleSheet')
  },
  get FlowTypes() {
    return require('./FlowTypes')
  },
}
```

2.

```
import Alert from './Alert'
import * as HOC from './HOC'
import Loading from './Loading'
import CustomSS from './CustomStyleSheet'
import * as FlowTypes from './FlowTypes'

module.exports = {
  Alert,
  HOC,
  Loading,
  CustomSS,
  FlowTypes
}
```

3.

```
import Alert from './Alert'
import * as HOC from './HOC'
import Loading from './Loading'
import CustomSS from './CustomStyleSheet'
import * as FlowTypes from './FlowTypes'

export {
  Alert,
  HOC,
  Loading,
  CustomSS,
  FlowTypes
}
```










### -16.6 
优化Overlay的调用方式，之前的TODO想用高阶组件实现，不可以，是反向的，直接继承即可，并且不需要再实现willMount和unmount，通过传参自定义显示动画也没必要，代码更乱

flow声明数组类型：`imgs: string[]`，或者`imgs: Array<string>`

关于在组件中声明props类型，使用flow的type还是react的propTypes，网上有很多比较，type是编码时的检查，propTypes是运行时的检查，应该都是必要的，虽然会导致代码重复

### -18.32 
研究第三方库，react-native-lottie是Airbnb开源的动画组件，在AE上制作的动画，通过一个插件导出json格式就可以在RN中使用，不会AE所以没办法用。react-native-animatable提供了很多动画效果

引入了一些旧的公共组件

参考ionc的alert、loading等组件，重新设计Overlay的创建和消失方法，不再公开Overlay的全部消失或者从顶层消失的方法，容易造成流程和代码混乱。把hide方法改成dismiss。有两种使用方法：

1. 每个Overlay都需要使用new新建实例，当显示时调用实例show方法，消失时调用实例的dismiss方法。不可以更新，如果要连续显示多个，需要先dismiss再新建（更新是个问题）
    
    ```
    let loading = new Loading('加载中...')
    loading.show()
    loading.dismiss()
    ```

2. Overlay新增type参数，可通过type来使Overlay消失。可直接调用Overlay组件的静态show和dismiss方法来快捷创建和消失

    ```
    Loading.show('加载中')
    // 让所有的Loading消失，调用dismissOverlayWithType方法
    Loading.dismiss()
    ```


### TODO
还需要重构Overlay，按照今天的思路修改底层逻辑，支持数据的更新

------

## 7.3 
### -11.34  
dva的回调和错误处理完成。自己实现了结果回调，然后想怎么处理错误就怎么处理。确定了API的调用方式，直接在effects中调用，能方便的进行错误判断，不需要创建双倍的文件，而不会多余一行代码

```
// HOC 中重新封装dispatch，返回一个promise对象，并把这个promise的resolve和reject传给dva，进行流程控制
dispatch: (type, payload) => {
   return new Promise((resolve, reject)=>{
    dispatch(createAction(type)(payload, resolve, reject))
  })
}

// model的effects
* [types.login]({payloa, resolve, reject}, {call, put}) {
  let {error, data} = yield call(post, '/login')  
  if (error) {
    reject(error)  
  } else {
    resolve(data)
    yield put(createAction(types.updateState)({auth: data}))
  }
}

// Components中进行流程控制（优化前的dva是不能进行流程控制的）：
try {
  let payload1 = await dispatch(types1, {})
  let payload2 = await dispatch(types2, {})
  let payload3 = await dispatch(types3, {})
} catch(e) {
}

// 老项目中redux-actions + redux-promise + redux-thunk配合的使用，繁琐了很多，而且不够先进
let {payload: payload1, error: error1} = await dispatch(types1, {})
let {payload: payload1, error: error2} = await dispatch(types1, {})
let {payload: payload1, error: error3} = await dispatch(types1, {})
```

修改网络请求的返回数据

```
// 以前的写法
try {
  return (await axios(config)).data
} catch (e) {
  return {error: _handleError(e, config)}
}

// 优化
try {
  return {data: (await axios(config)).data}
} catch (e) {
  return {error: _handleError(e, config)}
}

// 区别显而易见
// 修改前
let response = await get(...)
let data =  response
let error = response.error

// 修改后
let {data, error} = await get(...)
```






### -12.0 
受angular依赖注入的启发，把toast也当做props，放在HOC中传给container使用，可以直接用this.props.toast.show()来显示toast，不需要再次import Toast了



### -13.26 
再次重新设计Overlay，按照react组件的方式进行封装，需要哪个导入哪个，直接调用，而不是通过router调用，本来和router就没有关系




### 13.30-15.15 
开会

### -18.38 
重新设计组件的方式，老项目中每个组件都需要引入半页的子组件受够了

```
components 
--common
----index
----CustomStyleSheet
----HOC
----ActionSheet
----PropTypes
----Loading
----Toast
----OpacityButton
----Overlay
------index
------OverlayFade
--Topic
----index
----TopicRow
```

> 1. 把所有的Overlay、StyleSheet、HOC都放在common中，其实是参考了react源码的设计，把所有组件、API都放在一起，可以统一引入
2. Overlay只放Overlay方法和动画，要显示的Overlay组件还是放在common中

分模块导入，而不是分文件导入，节省了很多行代码

```
import {HOC, Alert, OpacityButton, PropTypes} from '../components/common'
import {TopicRow} from '../components/Topic'

// 对于组件的影响
type Props = PropTypes.Contaienr & {}
@HOC.container()
```

在Overlay的一个动画中引入StyleSheet导致重复引用搞了好久，common中的组件使用了Overlay，而Overlay中的一个动画又使用了common中的一个组件，最后还是通过相对路径导入来解决的，在其他文件中没有这样的问题：1）common中的组件互相引用的情况不多，直接import相对路径即可，而且将来移动位置，导入到其他工程可以不做一点改动。2）业务组件导入common正常，common导入业务组件的情况不可能发生

```
// 循环引用的解决方法
import {CustomSS} from '../common' // 错误
import CustomSS from '../common/CustomStyleSheet' // 正确
```

### TODO
1. Overlay组件支持配置自定义的进场出场动画
2. Overlay动画使用HOC来实现
3. PropTypes需要重命名，因为和react的PropTypes重名了，想不出来合适的

------

## 7.2 
### -11.50 
### 使用flow

1. 安装时候不能使用brew，会卡住，使用npm install flow-bin -g
2. 终端输入flow运行，但是报错版本不对。RN中默认生成了.flowconfig文件，并且指定了一个低版本的flow，修改[version]下面的版本号即可
3. 在每个需要检查的文件最上方加入`//@flow`或者`/*@flow*/`，或者给某个类、变量标注`//@flow`即可进行检查

### flow自带一个变量type，用于声明对象或者类的类型

```
type Prop = {}
type State = {}
class App extends PureComponent<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = {
    }
  }
}
```

### 忽略node_modules
.flowconfig

```
[ignore]
.*/node_modules/.*
```

### 运行提示react-native、redux等库找不到

```
// 需要VPN
yarn global add flow-typed
flow-typed install
```

修改后没好，重启下电脑就好了？

### @connect警告，忽略decorators
flow警告这还是一个提案，在.flowconfig忽略它，等号左右不能有空格

```
[optioins]
esproposal.decorators=ignore
```








### -15.35 
因为container需要props包含types、dispatch、router等固定props，而在每个container中都重复写一遍是很不明智的，而每个container都有各自单独的props，找到了一种办法可以合并不同的type


```
type ContaienrProps = {
  dispatch: mixed,
  types: mixed,
  router: Router
}

type Props = {
   id: string
}

class App extends PureComponent<ContainerProps & Props> {
  constructor(props: ContainerProps & Props) {
      super(props)
  }
}
```

上面的写法在constructor中比较繁琐，而且重复了，优化：

```
type ContaienrProps = {
  dispatch: mixed,
  types: mixed,
  router: Router
}

type Props = ContaienrProps & {
   id: string
}

class App extends PureComponent<Props> {
  constructor(props: Props) {
      super(props)
  }
}
```

封装在一个文件中：

```
PropTypes.js
export type ContainerProps = {
  dispatch: any, // 官方推荐能用mixed就不用any，但是在这个文件中使用mixed会报错，any就没有问题，需要再研究
  types: any,
  router: Router
}


// 导入
import type {ContainerProps} from '../utils/PropTypes'
```

dva的model.js不用flow，因为类型比较灵活，使用flow反而难以管理，处理数据的代码也会不整洁，flow现阶段只用来处理组件

至此，flow类型检查的错误全部修复




### -17.34 
手贱mac升级到10.14beta，一不操作电脑就死机

使用OC实现了一个mac小应用暂时避免这个问题。先实现循环模拟鼠标左键点击（经测试，只是鼠标没用。可以在外出时电脑后台开启），还需要今天和明天测试，因为上午和中午崩溃的次数较多，三四点以后几乎不崩溃，如果管用。明天再加强功能：监听鼠标的点击，如果20秒内没有点击，就开始模拟点击

> pyhook只支持windows，pyautogui需要quartz，quartz安装失败。node不能实现全局监听，只能监听程序本身的键盘输入。最后只能用mac原生实现

### -18.31 
接入登录API

1. 研究dva的回调和错误处理，dva的effects本身不支持返回promise来获取结果，一个大坑，需要自己实现结果回调，比较简单的是在dispatch最后添加一个参数onComplete，但是不喜欢回调的方式，想在creatAction中统一返回一个promise，错误处理也可以自己来控制
2. 探究更好的API调用方式（统一写在services/下还是直接放在models/中）

