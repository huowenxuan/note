# 大型网站架构技术 核心原理与案例分析（2013）
[TOC]

## 序
网站架构其实并不难，真正能解决问题的技术一定是简单的

## 1 大型网站架构演化

大型互联网应用系统的特点：
- 高并发，大流量
- 高可用：不间断服务，不宕机
- 海量数据
- 用户分布广泛，网络情况复杂
- 安全环境恶劣
- 需求快速变更，发布频繁
- 渐进式发展

### 大型网站架构演化发展历程
1. 初始：应用程序、数据库、文件都保存在一台服务器
2. 应用服务和数据服务分离：应用服务器（需要更快更强大的CPU）、文件服务器（需要更大的硬盘）、数据库服务器（需要更快的硬盘和更大的内存）。数据库称为性能的瓶颈。
3. 使用缓存改善性能：大部分的业务集中在一小部分数据上，将这一小部分数据缓存在内存中，减少数据库压力。缓存分为两种：1）本地缓存的速度更快，但是数据量有限，而且会和应用程序争内存。2）远程分布式缓存可使用集群的方式，部署在大内存的服务器上。此时数据库访问压力得到缓解，但是单一应用服务器能处理的请求连接有限，在访问高峰期，应用服务器成为网站的瓶颈
4. 使用应用服务器集群改善网站的并发处理能力：使用集群解决高并发、海量数据问题。当一台服务器存储空间不足时，不要去换更强大的服务器，不管多么强大的服务器，都满足不了持续增长的业务，应该增加一台服务器分担原有服务器的访问及存储压力。
    持续增加服务器改善性能，实现系统的可伸缩性。应用服务器实现集群是网站可伸缩集群架构设计中较为简单成熟的一种。通过负载均衡调度服务器，可将用户的访问请求分发到应用服务器集群中的任何一台服务器上
5. 发数据库读写分离：数据库经过读写分离后拆分成两台服务器。大部分服务器支持主从热备功能，通过配置两台数据库主从关系，可将一台数据库服务器的数据同步到另一台，可实现数据库读写分离，改善负载压力
    在写数据时，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库，当读取数据时，可通过从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离对应用透明
6. 使用反向代理和CDN加速网站响应：由于中国复杂的网络环境，不同地区的用户访问网站时速度差别也很大。他们的基本原理都是缓存，CDN部署在网络提供商的机房，请求数据时可从最近的网络提供商的机房获取；方向代理部署在网站的中心机房，当用户请求达到中心机房时，首先访问的服务器是反向代理服务器，如果其中国内缓存着用户请求的资源，就直接返回给用户
7. 使用分布式文件系统和分布式数据库系统：分布式数据库是数据库拆分的最后手段，只有在单表数据规模非常庞大时才使用，常用的的是数据库拆分手段是业务分库，将不同业务的数据库部署在不同的物理服务器上
8. 使用NoSQL和搜索引擎：由于数据存储和检索的需求越来越复杂，需要采用非关系数据库如NoSQL和非数据库查询技术如搜索引擎
9. 业务拆分：将不同的产品线，分归不同的业务团队负责。每个业务应用独立部署，应用之间通过超链接或通过访问同一个数据存储系统建立关系
10. 分布式服务：随着业务越拆分越小，系统存储越来越大，系统整体复杂程度上生，部署维护越来越困难。由于所有应用要和所有数据库系统连接，数据库连接资源不足拒绝服务。既然每个应用系统都要执行很多相同的业务操作（如用户管理、商品管理），可将这些共用的业务提取出来，独立部署，由这些可复用的业务连接数据库，提供共用业务服务，应用程序只需要管理用户界面，通过分布式服务调用共用业务服务。

### 大型网站架构演化的价值观
在网站还很小的时候就去追求架构师舍本逐末、得不偿失的。小型网站最需要的是提供好的服务来创造价值

大型网站架构的核心不是从无到有搭建一个大型网站，而是能报岁小型网站业务的逐步发展，慢慢演化成一个大型网站，不需要放弃什么、推翻什么，不需要剧烈的革命

### 误区
1. 一味追求大公司的解决方案
2. 为了技术而技术：脱离业务发展，一味追求时髦的新技术，可能会让架构之路越走越难
3. 企图用技术解决所有问题：有时真正的问题不是技术架构，而是业务架构。例12306：调整业务需求，在售票上引入了排队机制、整点售票改为分时段售票，控制住了并发访问的量，棘手的技术问题也不是问题了。**技术是用来解决业务问题的，而业务的问题，也可以通过业务的手段去解决**

## 2 大型网站架构模式
模式的关键在于模式的可重复性，问题与场景的可重复性带来解决方案的可重复使用

### 网站架构模式
#### 分层
在横向切分成几个部分，通过上层对下层的依赖和调用组成一个系统

分为应用层（展示）、服务层（为应用层提供服务支持）、数据层（数据库、缓存、文件、搜索引擎等）。应用层还可分为视图层和业务逻辑层，服务层可分为数据接口层和逻辑处理层。禁止跨层次的掉用、逆向调用。在部署上，三层结构分别部署在不同的服务器

在网站还很小的时候就该分层，将来可以更好的应付

#### 分割
在纵向对软件进行切分。将不同的功能和服务包装成高内聚低耦合的模块单元。在应用层（或服务层），将不同的业务分割，由不同的团队负责，不管是在逻辑上还是物理上，都是可以独立的

#### 分布式
分割和分层主要是为了模块便于分布式部署，将不同的模块部署在不同的服务器上，可用更多的机器完成同样的功能，解决高并发。

缺点：分布式调用网络会对性能造成影响；服务器越多，宕机的概率也越大；数据在分布式环境中保持一致性也很难，分布式事务也难以保证；导致网站依赖错综复杂，难以开发维护。因此要量力而行，不要为了分布式而分布式

常用的分布式方案：
1. 分布式应用和服务：将分层和分割后的模块进行分布式部署，可改善性能和并发性、加快开发和发布速度、减少数据库连接消耗、使不同的应用服用共同的服务，便于业务扩展
2. 分布式静态资源：**动静分离**，静态资源独立分布式部署，并采用独立的域名（加快浏览器并发加载的速度），减轻应用服务器的负载压
3. 分布式数据和存储：对传统的关系型数据库、各种NoSQL都进行分布式部署
4. 分布式计算：除了应用、服务、实时数据处理等在线业务外，后台业务的计算规模也非常庞大：搜索引擎的索引构建、数据仓库的数据分析统计等，目前普遍使用Hadoop和MapReduce分布式计算框架进行此类批处理计算，其特点是移动计算而不是移动数据，将计算程序分发到数据所在的位置以加速计算和分布式计算

#### 集群
对于用户集中的模块（例如首页），还需要将独立部署的服务器集群化（多台服务器部署相同应用构成一个集群），通过负载均衡设备共同对外提供服务。更好的并发。当某台服务器发射管你故障，可以转发到其他服务器上，所以即使访问量很小的分布式应用和服务，也应该至少部署两台服务器构成一个集群，提高系统可用性

#### 缓存
- CDN
- 反向代理
- 本地缓存：应用本地缓存
- 分布式缓存：将数据缓存在分布式缓存集群中

#### 异步
在单一服务器可使用多线程共享内存队列的方式实现异步；在分布式系统中，多个服务器集群通过分布式消息队列实现异步。异步架构的典型是生产者消费者模式

特性：
- 提高系统可用性：消费者服务器发生故障时，数据会在消息队列服务器中存储堆积，生产者服务器可以继续处理业务请求，系统整体表现无故障，当消费者恢复后，继续处理消息队列中的数据
- 加快网站响应速度：将请求写入消息队列不需要处理就可返回，响应延迟减少（但是获取不到结果）
- 消除高并发访问高峰：将突然增加的访问请求数据库放入消息队列中，依次处理，就不会对网站负载造成太大压力

可能会对用户体验、业务流程造成影响，需要网站产品设计方面的支持

#### 冗余
想保证服务器宕机依然可以运行，不丢失数据，就需要一定程度的服务器冗余运行，数据冗余备份，当某台服务器宕机，可将其上的服务和数据访问转移到其他机器上

服务器需要定期冷备份，也需要对数据库进行主从分离，实时同步实现热备份

#### 自动化
通过减少人为干预，使发布过程自动化可有效减少发布故障

1. 自动化代码管理：代码版本控制、代码分支创建合并自动化
2. 自动化测试：开发完成提交测试后，系统自动将代码部署到测试环境，启动自动化测试用例进行测试
3. 自动化安全测试：安全检测工具对代码进行静态安全扫描以及部署到安全测试环境进行安全攻击测试，评估其安全性
4. 自动化部署
5. 自动化监控：进行心跳检测，并监控各项性能和关键数据指标
6. 自动化报警：如遇到异常，发送报警信息
7. 自动化失效转移：故障发生后，将失效的服务器从集群中隔离出去
8. 自动化失效恢复，当然故障消除，重新启动服务
9. 自动化降级：当网站遇到高峰，超出最大处理能力，会进行自动化降级，拒绝部分请求及关闭部分不重要的服务将负载降至安全的水平
10. 自动化分配资源：将空闲资源分配给重要的服务，扩大其部署规模

#### 安全

- 通过密码和手机验证码进行身份确认
- 登陆、交易对网络通信进行加密
- 敏感数据加密处理
- 防止机器人滥用网络资源攻击网站，使用验证码进行识别
- 用于攻击网站的XSS攻击、SQL注入，进行编码转换等处理
- 垃圾信息、敏感信息进行过滤
- 对交易转账等重要操作根据交易模式和交易信息进行风险控制

### 架构模式在新浪微博的应用

发微博后将微博写入消息队列后立即返回，响应迅速，消息队列付费者任务将微博推送给所有当前在线粉丝的订阅列表中，非在线用户通过拉取的方式获取

由于刷新频繁，使用多级缓存策略，将热门微博和明星用户的微博缓存在所有微博服务器，在线用户的微博和近期微博缓存在分布式缓存集群中，刷微博几乎都是缓存访问操作

## 3 大型网站核心架构要素
系统的各个重要组成部分及其关系构成了系统的架构，这些组成部分可以是具体的功能模块，也可能是非功能的设计与决策。除了系统功能需求外，软件架构还需要关注性能、可用性、伸缩性、扩展性和安全性

### 性能
- 浏览器端：浏览器缓存、页面压缩、合理布局页面、减少Cookie传输、CDN
- 应用服务器端：缓存、通过异步将请求发送至消息队列等待后续处理、多台应用服务器组成集群
- 代码：多线程、改善内存管理
- 数据库：索引、缓存、SQL优化、NoSQL通过优化数据模型、存储结构、伸缩特性等手段在性能方面也具有优势

### 可用性
网站宕掉、服务不可用是重大事故，影响网站声誉，还可能摊上官司。高可用架构架构设计的前提是必然会出现服务器宕机（硬件故障），高可用设计的目标就是当服务器宕机以及出现各种不可预期的问题时，服务或应用依然可用。

网站高可用主要手段是冗余，应用部署在多台服务器上同时提供访问，数据在多台服务器上互相备份，任何一台服务器宕机都不会导致应用的整体可用，也不会导致数据丢失。

对于因应用服务器，通过负载均衡设备组成一个集群共同提供服务，当一台服务器宕机时，只需把请求切换到其他服务器就可实现应用高可用，但前提是应用服务器上不能保存请求的会话信息，否则宕机后会话丢失，即使转发到其他服务器也无法完成业务处理

对于存储服务器，数据实时备份，宕机时将数据访问转移到可用的服务器，进行数据恢复保证继续有服务器宕机时数据依然可用

### 伸缩性
指通过不断向集群中加入服务器的手段来缓解不断上升的并发压力和数据存储需求。衡量标准是是否可用多台服务器构架集群，增加服务器是否方便，加入后是否可以提供无差别服务，集群中可容纳的总的服务器数量是否有限制

对于应用服务器集群，只要不保存数据，所有服务器都是对等的，通过负载均衡就可以加入服务器

对于缓存服务器集群，加入新的服务器可能导致缓存路由失效，导致大部分缓存数据无法访问，需要改进就缓存路由算法保证缓存数据的可访问性

关系型数据库虽然支持数据复制、主从热备，但是很难做到大规模集群的可伸缩性，因此关系数据库的集群伸缩方案必须在数据库之外实现，通过区分路由等手段将部署有多个数据库的服务器组成一个集群

对于大部分NoSQL，先天就是为海量数据而生的，因此对伸缩性的支持都非常好，可以较少运维的情况下实现伸缩

### 扩展性
网站的扩展性直接关注网站的功能需求，如何设计网站的架构使其能快速响应需求变化，是可扩展架构的主要目的。衡量的标准是在增加新业务时，是否可以对现有产品透明无影响，不需要或只要很少改动就可以上线新产品，不同产品之间少耦合

可扩展架构的主要手段是事件驱动架构和分布式服务
事件驱动架构：使用消息队列实现，可透明底增加新的消息生产者、消费者任务
分布式服务：将业务和可复用服务分开，通过分布式框架调用，新增产品直接调用服务，对现有产品无影响

大型网站为了保持市场地位，会吸引第三方开发者，为他们提供开放平台

### 安全性
针对攻击和窃密，是否有应对策略

## 4 瞬时响应：网站的高性能架构
### 网站性能测试
**性能测试指标**
1. 响应时间。收到响应和发出请求之间的时间差，测试程序也需要花费时间，所以通常采用重复请求（重复一万次，总时间除以一万）
2. 并发数。同时处理的数目。测试程序通过多线程模拟并发用户来测试系统的并发处理能力，并不是不停地发送请求。而是两次请求之间加入一个随机等待时间（称为思考时间）
3. 吞吐量。但是时间内系统处理的请求数量，提现系统的整体处理能力。TPS（每秒事务数）是常用来量化吞吐量的指标，HPS（每秒HTTP请求数）、QPS（每秒查询数）
4. 性能计数器。描述服务器或系统性能的一些数据指标，也是系统监测的重要指标。System Load、对象与线程数、内存使用、CPU使用、硬盘与网络I/O等
    System Load：系统负载，正在和等待被CPU执行的进程数目总和，反应系统忙闲程度，Load的理想值是CPU数量。高于CPU时表示进程在排队等待CPU调度，系统资源不足
    
**性能测试的方法**
性能测试
负载测试
压力测试
稳定性测试

### Web前端性能优化
**浏览器访问优化**
1. 较少http请求，每次http请求都要建立通信链路，服务器端每个http请求都需要启动独立的线程处理。主要手段是合并CSS、合并JavaScript、合并图片
2. 使用浏览器缓存。使用缓存的网站在更新静态资源时，如果要即时更新，可修改资源文件名；更新多个文件应该逐量更新，有一定的时间间隔，以免用户集中更新缓存，造成服务器负载骤增
3. 启用压缩，文本文件的压缩率可达到80%以上，HTML、CSS、JavaScript启用GZip压缩，但是压缩会对服务器和浏览器产生一定压力（在通信良好，服务器资源不足的情况下就不要压缩了）
4. CSS放在页面最上面、JS放在最下面。浏览器会在下载完CSS后才对页面渲染，JS在加载后立刻执行，可能会阻塞页面，所以放在最下面（页面解析的JS例外）
5. 减少Cookie传输。大量Cookie严重影响数据传输，尽量减少Cookie中传输的数据量，对于静态资源发送Cookie没有意意义，将静态资源放在独立域名，避免这种情况

**CDN**
**反向代理**

### 应用服务器性能优化
#### 布式缓存
缓存的本质是一个内存Hash表。缓存遵循二八定律，80%的访问落在20%的数据上（大部分数据访问集中在小部分数据上），只缓存这20%的数据

**缓存滥用**
- 频繁修改的数据：会出现写入缓存后，还来不及读取缓存，数据就已失效，一般数据的读写比在2:1（写入一次缓存，在更新前至少读取两次）以上，缓存才有意义
- 没有热点的访问：内存资源宝贵，只能将最新访问的数据缓存起来，历史数据清除，如果数据没有热点，不遵循二八定律，缓存就没有意义
- 数据不一致与脏读：缓存要容忍一定时间的数据不一致（有失效时间）。可以数据更新时立即更新缓存，但是会带来更多系统开销和事务一致性的问题
- 缓存可用性：缓存数据丢失或不可用不会影响到应用程序的处理
- **缓存预热：最好在缓存系统启动时就把热点数据加载好，例如一些元数据（城市地名列表、类目信息）**
- **缓存穿透：因为不恰当的业务或恶意攻击持续高并发地请求某个不存在的数据，对数据库造成很大压力，一个简单的对策是将不存在的数据也缓存起来（值为null）**

#### 异步操作
消息队列，改善扩展性，改善性能。在电子商务网站促销活动中，可使用消息队列。缺点是在后续的业务校验、写数据库操作可能失败发，所以不能立刻告知用户提交成功，应该发送消息、邮件等通知用户

#### 集群
#### 代码优化
1. 多线程。解决线程安全问题：
    1. 将对象设计为无状态对象：对象本身不储存状态（无成员变量，或变量也是无状态对象），这样就不会出现状态不一致，Java Web的Servlet就是无状态对象，从面向对象的角度看，无状态对象是不良设计
    2. 使用局部对象：方法内部创建的对象，会被每个进入方法的线程创建，不会出现被多线程并发访问的问题
    3. 并发访问资源时使用锁：使多线程并发操作转化为顺序操作，避免并发修改，因为同步顺序执行，可能会对性能产生严重影响
2. 资源复用：减少开销大的系统资源的创建和销毁，数据库连接、网络通信连接、线程、复杂对象，资源复用主要有两种模式
    1. 单例Singleton
    2. 对象池Object Pool：数据库连接基本使用对象池，连接好后，将连接对象放入对象池容器中，需要连接时，从池里获取一个空闲的连接，用完后归还到对象池。web请求采用线程池，连接池、线程池都属于对象池
3. 数据结构
    在不同场合使用恰当的数据结构
    缓存为Hash表，Hash表的读写性能依赖HashCode的随机性，越散列随机，冲突越少、读写性能越高
4. 垃圾回收

#### 存储性能优化
1. 机械硬盘 vs. 固态硬盘
    SSD >> 机械，在性能、功耗方面
2. B+树 vs. LSM树
    传统数据库在保证数据在增删改查后依然有序的做法是使用B+树。B+树是专门针对**磁盘存储**而优化的N叉排序树，以树节点为单位储存在硬盘中。数据库多采用两级，树的层次最多为三层，可能需要5次磁盘访问才能更新一条记录
    很多NoSQL使用LSM树。LSM可看做N阶合并树，数据增删改都在内存进行，而且都会创建一个新记录，这些数据在内存中还是一颗排序树，数量过多会有合并的操作。在进行读操作时，先从内存中的排序树中查找，找不到就从硬盘上的排序树顺序查找。在LSM上进行数据更新不需要访问硬盘，只需要访问内存，速度远快于B+树。当数据访问以写操作为主，读操作则集中在最近写入的数据上时，使用LSM数可极大程度减少硬盘的访问次数，加快访问速度
    B+不是关系数据库独有的，NoSQL也可以使用B+，关系数据库也可使用LSM，B+会随着SSD的出现再次焕发青春
    
#### RAID vs. HDFS

RAID（链家硬盘冗余阵列）为了改善硬盘的访问延迟，增强硬盘的可用性和容错能力，使用RAID技术，实现数据在多块硬盘上的并发读写和数据备份。
RAID可通过硬件实现，比如专用的RAID卡或主板直接支持，也可通过软件实现。    
RAID在关系型数据库以及文件系统中应用比较广泛，但是NoSQL以及分布式文件系统中，RAID遭到冷落

HDFS（Hadoop分布式文件系统）中，系统在整个存储集群的多台服务器上进行数据并发读写和备份，可看做在服务器集群实现了类似RAID的功能，因此不需要磁盘RAID。
HDFS以块（Block）为单位管理文件内容，一个文件被分割成若干Block，每写完一个Block，HDFS将将其自动复制到另外两台机器上，即使服务器宕机，数据依然可以访问。当进行处理计算时，可启动多个计算子任务，同时读取文件的多个Block，并发处理

## 5 万无一失：网站的高可用架构
### 度量
两个9是基本可用（99%可用，一年中不可用时间小于88小时），三个9是较高可用（9小时），4个9是高可用（53分钟），5个9是极高可用（5分钟）
### 高可用应用
应用服务器高可用主要基于服务无状态：不保存业务上下文信息，仅根据每次请求来处理，多个服务器完全对等，处理结果相同。

1. 通过负载均衡进行无状态服务的失效转移
2. 应用服务器集群的Session管理：Session服务器？？

### 高可用服务
1. 分级管理：核心应用和服务使用更好的硬件。在部署上也进行隔离，避免故障的连锁反应，低优先级的服务通过不同线程或部署在不同虚拟机进行隔离；高优先级部署在不同的物理机；核心服务和数据部署在不同地域的数据中心
2. 超时设置：超时后抛出异常，重试或转移到其他服务器，防止占用资源
3. 异步调用：消息队列
4. 服务降级：访问高高峰期，防止大量并发导致性能下降，为保证核心功能的正常使用，拒绝低优先级的调用，关闭不重要的服务
5. 幂等性设计：服务重复调用是不可避免的，所以必须在服务层保证服务重复调用和调用一次产生的结果相同，即服务具有幂等性。如转账等交易，需要进行有效性校验，才能继续执行

### 高可用的数据

- 数据持久性：可持久存储，各种情况下都不会出现数据丢失的问题
- 数据可访问性：如果一个数据存储设备损坏，可将数据访问切换到另一个数据存储设备上，如果这个过程不能很快完成（用户几乎没有感知），或者完成过程中需要停止终端用户访问数据，都是不可访问的
- 数据一致性：多份副本的数据一致。有时会出现部分副本写入成功，部分写入失败。通常发生在高并发或集群状态不稳定（故障恢复、集群扩容等）
    - 数据强一致：各个副本的数据总是一致的，数据更新和响应总是一致的，如果操作更新失败，那么数据一定没有被更新，而不是处于不确定状态
    - 数据用户一致：各个副本的数据可能不一致，但是用户访问时，通过纠错和校验机制，返回一个正确的数据。一般达到用户一致即可
    - 数据最终一致：一致性最弱，存储的数据可能是不一致的，用户访问到的数据也可能是不一致的，但系统经过一定时间的恢复和修正，数据达到一致

手段有数据备份、失效转移

#### CAP原理
为了保证数据的高可用，通常会牺牲另一个也很重要的指标：数据一致性

CAP原理认为，一个提供数据服务的存储系统无法同时满足数据一致性、数据可用性、分区耐受性（可伸缩性：系统具有跨网络分区的伸缩性）这三个条件。要保证分布式处理系统的高可用性，在大型网站中，通常会强化分布式存储系统的可用性和伸缩性，一定程度放弃一致性

#### 数据备份
- 冷备：放到存储介质。简单廉价，不能保证数据最终一致，不能保证数据可用性，恢复要较长时间，这段时间内无法访问
- 热备：
    - 异步热备：多份副本写入操作异步完成。数据访问在主存储服务器，数据写入时通过异步操作将数据同步到从服务器
    - 同步热备：同步操作，可能因为网络原因，收到部分副本同步失败的响应（其实是成功了）。没有主从之分，全部同时写入数据，响应时间为最慢的响应延迟时间

#### 失效转移
1. 失效确认：心跳检测和婴童程序访问失败报告->再次心跳检测确认
2. 访问转移：将数据访问重新路由到其他服务器
3. 数据恢复：从健康的服务器复制数据，将数据副本数目恢复到设定值

### 高可用网站的软件质量保证 
- 网站发布：在重新部署时不影响用户的使用。发布过程中，每次关闭的服务都是集群中的一小部分，在发布后立即可以访问，因此整个发布过程不影响用户使用。过程：1）关闭负载均衡服务器上一台或一小批服务器路由。2）关闭这些服务器应用。3）同步（复制）软件代码到这些服务器。4）启动这些服务器。5）打开负载均衡服务器上这些服务器的路由。6）判断集群所有机器是否发布完成
- 自动化测试
- 预发布验证：发布之前先发布到预发布机器上，进行预发布验证，执行一些典型的业务流程，没问题后正式发布。预发布服务器和正式服务器唯一的不同就是没有配置在负载均衡服务器上，外部用户无法访问（物理环境相同、依赖的服务相同、配置相同）
- 代码控制，有以下两种方式
    - 主干开发，分支发布：代码修改都在主干进行，发布时从主干拉一个分支发布，该分支成为一个发布版本，该版本发现bug，继续在分支上修改发布，并merge回主干。主干反应目前整个应用状态，一目了然，便于管理和控制，利于持续集成。对于不同开发周期、发布时间的项目，需要等最慢的开发完成后才可以发布。
    - 分支开发，主干发布：任何修改都不得在主上直接进行，在分支开发，测试通过后合并回主干，从主干发布。各个分支独立进行，互不干扰，可以使不同发布周期的开发一起进行（主流）
- 自动化发布：自动构造代码分支，进行代码合并，执行发布脚本。人的干预越少，自动化程度越高，引入故障的可能性就越小
- 灰度发布：将来集群服务器分成若干部分，每天只发布一部分服务器，观察运行稳定没有故障，持续几天才全部发布，如果发现问题，只需要回滚已发布的一部分服务器即可，防止集群全部回滚时间太长。也用于用户测试，在部分服务器发布，监控用户操作，收集体验报告，比较用户对两个版本的满意度（AB测试）
- 网站运行监控
    - 服务器端日志。IP可能是代理IP
    - 客户端浏览器日志。数据更精准，但是比较麻烦
    - 服务器性能监控
    - 运行数据：与业务场景吸纳过关的技术和业务指标（如缓冲命中率、响应延迟、每分钟发送邮件数目、待处理任务总数等）

## 6 永无止境：网站的伸缩性架构
伸缩性：不需要改变网站的软硬件设计，仅通过改变部署的服务器数量就可以扩大或缩小网站的处理能力。最重要的就是集群

### 网站架构的伸缩性设计
1. 不同功能进行物理分离实现伸缩：不同服务器部署不同的服务，提供不同的功能。从早期就需要
    1. 纵向分离（分层后分离）：将业务处理流程上的不同部分分离部署（数据库、基础技术服务、可复用业务服务、网站具体产品）
    2. 横向分离（业务分割后分离）：将不同的业务模块分离部署
2. 单一功能通过集群规模实现伸缩：多台服务器部署相同的服务，提供相同的功能。在网站访问量增大、单一服务器不能满足业务规模时需要

### 应用服务器的伸缩性设计
当HTTP请求分发装置可以及时发现已上线或下线的服务器，并能向新上线的服务器分发请求，停止向已下线的服务器分发请求，就实现了应用服务器集群的伸缩性。这个HTTP请求分发装置被称作负载均衡服务器。

### 实现负载均衡的基础技术
1. HTTP重定向负载均衡：HTTP重定向服务器就是一台普通的服务器，根据用户请求获取到用户ip地址，再通过负载均衡算法获得一台服务器的地址，构造一个重定向响应返回给浏览器
    优点：简单
    缺点：浏览器需要请求两次；集群伸缩性规模有限；使用302可能使搜索引擎判断为SEO作弊，降低搜索排名，所以不多见。
2. DNS域名解析负载均衡：利用DNS处理域名解析请求的同时进行负载均衡处理。在DNS服务器中配置多个A记录，每次域名解析请求都会根据负载均衡算法计算一个不同的ip地址返回
    优点：将负载均衡交给DNS，省去了维护的麻烦；还支持基于地理位置的域名解析，改善性能
    缺点：DNS可能缓存A记录，当下线某台服务器后，修改A记录也需要较长时间才会生效；DNS负载均衡的控制权在服务商那里，网站无法做更多的改善和管理
3. 反向代理负载均衡：反向代理服务器位于Web服务器前面（可缓存资源，改善网站性能）（也叫应用层负载均衡），也同时提供负载均衡的功能。管理一组web服务器，将请求根据负载均衡算法转发到不同的web服务器上，web服务器的响应也需要通过反向代理服务器返回给用户。web服务器不需要使用外部ip地址，但是反向代理服务器需要配置双网卡和内部外部两套ip地址
    优点：负载均衡和反向代理服务器功能集成在一起，部署简单
    缺点：反向代理服务器是所有请求的中转站，性能可能会成为瓶颈
4. IP负载均衡：通过修改请求目标地址进行负载均衡。负载均衡服务器在操作系统内核获取网络数据包，根据负载均衡算法得到真实web服务器地址，然后将目的ip改为服务器地址，当响应数据包回到负载均衡服务器，再将数据包ip地址修改为自身的ip发送给用户
    优点：因为在内核操作，所以比反向代理负载均衡有更好的处理性能
    缺点：所有请求响应都需要经过负载均衡服务器，吞吐量受限于带宽，对于提供下载或视频等网站难以满足需求
5. 数据链路层负载均衡：在通信协议的数据链路层修改mac地址进行负载均衡。又称三角传输模式、直接路由方式（DR），分发过程中不修改ip，指修改目的mac地址，通过配置真实物理服务器集群所有机器虚拟ip和负载均衡服务器ip地址一致，达到不修改数据包的源地址和目的地址就能进行数据分发的目的。使用最广泛，在Linux平台最好的是LVS（Linux Virtual Server）
    优点：由于ip一致，不需要通过负载均衡服务器进行地址转换，可以将响应直接返回给用户，避免负载均衡服务器网卡带宽成为瓶颈

### 负载均衡算法
实现可分成两部分：
1. 根据负载均衡算法和Web服务器列表计算得到集群中一台Web服务器的地址
2. 将请求数据发送到该地址对应的Web服务器

负载均衡算法：
1. 轮询：所有请求被依次分发到每台应用服务器上，每台服务器需要处理的请求数目都相同，适用于所有服务器硬件都相同的场景
2. 加权轮询：在轮询的基础上，根据应用服务器硬件性能情况分配，高性能的服务器分配更多请求
3. 随机：简单实用，在硬件不同的情况下，可以使用加权随机
4. 最少连接：记录每个服务器正在处理的请求数，新的请求分配到最少连接的服务器，最符合负载均衡定义的算法，可实现加权最少连接
5. 源地址散列：根据请求ip进行Hash计算，得到应用服务器，来自同一ip的请求总是在同一个服务器，请求的上下文可存储在这台服务器上

### 分布式缓存集群的伸缩性设计
不能使用简单的负载均衡手段来实现。分布式缓存服务器集群中不同服务器缓存的数据不同，必须先找到有需要数据的服务器，才能访问。这个特点会严重制约分布式缓存集群的伸缩性设计，因为新上线的服务器没有数据，而已下线的服务器还缓存着热点数据。主要目标就是必须在新加入缓存服务器后，之前已缓存的数据还能被访问到，新上线的缓存服务器对整个集群的影响最小

简单的路由算法是余数Hash，如果不考虑伸缩性，可以满足绝大多数的缓存路由需求，但是当集群需要扩容时，命中的概率大大降低

比较流行的路由算法是一致性Hash算法

### 数据存储服务器集群的伸缩性设计
对数据的持久性和可用性提出了更高的要求

#### 关系型数据库集群伸缩性设计
使用自带的数据复制功能，可以进行简单伸缩，有主从之分，写操作在主服务器，主服务器将数据同步到集群中其他从服务器，读操作以及数据分析等离线操作在从服务器进行

不同业务数据表部署在不同的集群上，即数据分库，去诶单是跨库的表不能进行join操作

目前比较成熟的支持数据分片的分布式关系数据库产品主要有Amoeba、Cobar

Cobar是一个分布式关系数据库访问代理，介于应用服务器和数据服务器之间，根据SQL和分库规则分解SQL，分发到mysql集群不同的数据库实例上执行（每个MySQL实例都部署为主从结构，保证数据高可用），最后将结果集合合并成一个结果集。

Cobar无法执行跨库的join操作，更不能执行跨库的事务处理。目前各类分布式关系数据库解决方案都显得非常简陋，限制了数据库的某些功能，必须从业务上回避分布式关系数据库的各种缺点：避免事务或利用事务补偿机制代替事务；分解数据访问逻辑避免JOIN操作

GreePlum等一部分分布式数据库支持JOIN，但是访问延迟比较大，一般用在数据仓库等非实时业务中

#### NoSQL数据库的伸缩性设计
对于关系型数据库的缺点：先设计数据库然后设计程序，导致惯性系模型绑架对象模型；糟糕的海量数据处理；僵硬的设计约束。为了它的不足，NoSQL出现了

NoSQL：非关系的、分布式的数据库设计模式。放弃了关系数据库的两大重要基础：以关系代数为基础的结构化查询语言（SQL）和事务一致性（ACID），而强化其他一些大型网站更关注的东西：高可用和可伸缩性

## 7 随需应变：网站的可扩展架构
扩展性和伸缩性的区别：
- 扩展性：对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。表现在基础设施稳定不需要经常更换，应用之间依赖和耦合较小，对需求变更可以敏捷响应。是系统架构设计层面的开闭原则（对扩展开放。对修改关闭），当系统增加新功能时，不需要对现有系统进行修改
- 伸缩性：通过增加（减少）自身资源规模的方式增强（减少）计算处理事务的能力

### 构建可扩展的网站架构
开发低耦合系统是软件设计的终极目标之一。从汇编到面向过程到面向对象向，从各种软件工具集到各种开发框架。度量一个开发框架、设计模式、编程语言的优劣的重要尺度就是衡量它是不是让软件开发过程和软件产品更加低耦合

软件架构师最大的价值不在于掌握多少先进的技术，而在于具有将一个大系统切分成N个低耦合的子模块的能力，包括横向的业务模块、纵向的基础技术模块

设计网站可扩展架构的核心思想是模块化，并在此基础上，降低模块间的耦合性，提高模块的复用性

### 利用分布式消息队列降低系统耦合性
#### 事件驱动架构 EDA
> 通过在低耦合的模块之间传输事件消息，保持模块的松散耦合，借助事件消息的通信完成模块间合作

典型的EDA架构是生产着消费者模式，实现的手段最常用的是分布式消息队列

#### 分布式消息队列
消息队列利用发布——订阅模式工作，消息发送者发布消息到消息队列，一个或多个消息接收者订阅消息，从分布式消息队列获取消息后进行处理，不需要知道消息从何而来。对新增业务，只需要对该类消息感兴趣，即可订阅该消息，实现业务的可扩展设计

消息发送者不需要等待消息消息接收者处理数据就可以返回，具有良好的响应延迟；消息可暂时存储在队列中，消息接收者根据自身负载处理能力控制处理速度，减轻数据库的负载压力

- 伸缩性：消息队列服务器上的数据是被即时处理的，所以类似无状态服务器，伸缩性设计简单，新服务器加入队列集群中，通知生产者服务器更改消息队列服务器列表即可
- 可用性：如果内存队列已满，会将消息写入硬盘。为了避免消息队列服务器宕机造成消息丢失，会将发送成功的消息存储在生产者服务器，等真正被消费者服务器处理后才删除消息。宕机后，生产者服务器会选择集群中其他服务器发布消息

### 可扩展的数据结构
传统数据库僵硬的数据结构难以面对及需求变更带来的挑战，通过冗余的字段来应对，是糟糕的数据库设计

许多NoSQL数据库使用的ColumnFamily（列族）设计就是一个可扩展数据结构解决方案，在建表时，只需要指定ColumnFamily的名字，无需指定字段，可以在数据写入时候再指定

### 利用开放平台建设网站生态圈
大型网站为了更好的服务自己的用户，开发更多的增值服务，会把内部的服务封装成接口开放出去，供外部第三方开发者使用，这个平台为开放平台。网站、用户、第三方开发者互相依赖，形成一个网站的生态圈，为用户提供更多的价值，也提高了网站和第三方开发者的竞争能力和盈利能力

- API接口：暴露给开发者使用的一组API
- 协议转换：将各种API输入转换成内部服务可以识别的形式，并将内部服务的返回封装成API的格式
- 安全：身份识别、权限控制、分级的访问宽带限制，保证平台资源被公平合理使用，也保护网站内部服务不会被外部应用拖垮
- 审计：记录第三方应用的访问情况，进行监控，计费
- 路由：将各种访问路由映射到具体的内部服务
- 流程：将一组离散的服务组织成一个上下文相关的新服务，隐藏服务细节，提供统一接口

## 8 固若金汤：网站的安全架构
### 网站应用攻击与防御
#### XSS攻击
跨站点脚本攻击（Cross Site Script），黑客通过篡改网页，注入恶意HTML脚本，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式

- 反射型：攻击者诱使用户点击一个嵌入恶意脚本的链接，达到攻击的目的。可偷取用户Cookie、密码等重要数据
- 持久型：黑客提交含有恶意脚本的请求，保存在被攻击者的Web站点的数据库中，用户浏览网页时，恶意脚本被包含在正常页面中，达到攻击的目的。常用在论坛、博客等Web应用中

XSS攻击是一种古老的攻击手段，却又历久弥新，不断出现新的攻击花样，主要放攻击有如下两种：
1. 消毒：XSS一般都是通过在请求中嵌入恶意脚本达到攻击目的，这些脚本是一般用户输入中不使用的，通过对某些html危险字符转义，就可防止大部分攻击。如“>”转为“\&gt;”，“<”转为“\&lt;”。为了避免不必要的内容错误转义，如果“3<5”，需要进行文本匹配后转义，如“<img src=”这样的上下文中才转义。消毒几乎是所有网站最必备的XSS防攻击手段
2. HttpOnly：浏览器禁止页面JavaScript访问带有HttpOnly属性的Cookie。HttpOnly并不是直接对抗XSS攻击的，而是防止XSS攻击者窃取Cookie。对于带敏感信息的Cookie，可通过对该Cookie添加HttpOnly属性，避免被窃取

#### 注入攻击
**SQL注入攻击**
攻击者在HTTP请求中注入恶意的SQL命令，服务器用请求参数构造数据库SQL命令时，恶意SQL被一起构造，并执行。SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者获取数据库表结构信息的手段有如下几种：
    1. 开源：如果网站使用开源软件搭建，数据库结构就是公开的
    2. 错误回显：如果网站开启错误回显（500错误会显示到浏览器上）。攻击者通过故意构造非法参数，使服务器端异常信息输出到浏览器端，就可能猜到表结构
    3. 盲注：网站关闭错误回显，攻击者通过页面变化猜测SQL语句的执行情况，因此猜测数据库表结构，此种方式难度较大

防御SQL注入攻击
1. 首先要避免被攻击者猜测到表名等数据库表结构信息
2. 消毒：通过正则匹配，过滤请求数据中可能注入的SQL：如“drop table”
3. 参数绑定：使用预编译手段，绑定参数是最好的防SQL注入方式。目前许多数据库访问层框架，如IBatis、Hibernate等，都实现SQL预编译和参数绑定，攻击者的恶意SQL会被当做SQL的参数，而不是SQL命令被执行（Sequlize也支持）

> 例如`SELECT {a} FROM users`，参数a可通过请求传入，这是如果参数的值为`drop table users`，就可能会被攻击成功。而绑定参数的功能会把该参数当做参数值，而不是SQL语句

- OS注入攻击
- 编程语言代码注入。利用程序漏洞达到攻击目的
 
#### CSRF攻击
Cross Site Request Forgery 跨站点请求伪造，攻击者通过跨站请求，以合法用户的身份进行非法操作，如转账交易、发表评论等，伪造用户请求。其核心是利用了浏览器Cookie或服务器Session策略，盗取用户身份。
 
CSRF防御手段主要是识别请求者身份：
1. 表单Token：在页面表单中增加一个随机数作为Token，每次响应页面的token都不相同，从正常页面提交的请求中包含该Token值，而伪造的请求无法获得该值，伪造的请求无法获得该值，服务器检查请求参数中Token的值是否存在且正确
2. 验证码：更加简单高效，但请求提交时，需要用户输入验证码，是糟糕的用户体验，应该只在支付交易等关键页面使用
3. Referer check：HTTP请求头Referer中记录着请求来源，通过它检查是否合法。可实现图片防盗链

#### 其他攻击和漏洞

**Error Code**
错误回显，服务器端未处理的异常堆栈信息会直接输出到客户端浏览器，虽然对调试和错误报告有好处，但会被其他人利用，故意制造非法输入，使系统运行出错，获得异常信息，从而寻找系统漏洞。防御很简单，配置跳转500页面到专门的错误页面即可

**HTML注释**
在页面中的HTML注释也会给黑客造成攻击便利

**文件上传**
如果上传的是可执行程序，并通过该程序获得服务器端命令执行能力，那么攻击装几乎可以为所欲为。最有效的防御手段是设置上传白名单，只允许上传可靠的文件类型，还可修改文件名、使用专门的存储等手段

**路径遍历**
攻击者在请求的URL中使用相对路径，遍历系统未开放的目录和文件。防御方法主要是将js、css等资源文件部署在独立服务器、使用独立域名，其他资源不使用静态URL访问，动态参数不包含文件路径信息

#### Web应用防火墙
统一拦截请求，过滤恶意参数、自动消毒、添加token、并能根据最新攻击和漏洞情报，不断升级对策，处理掉大多数网站攻击——ModSecurity，支持nginx

#### 网站安全漏洞扫描
网站安全漏洞扫描工具根据规则，构造具有攻击性的URL请求，模拟黑客攻击，发现网站安全漏洞

### 信息加密技术及密钥安全管理
应用需要对网站的敏感数据进行加密，加密技术分为三类
#### 单项散列加密
> 对不同输入长度的信息进行散列计算，得到固定长度的输出，散列计算过程是单项的，不能通过输出计算输入；而且输入的任何微小变化都会导致输入的完全不同。
> 虽然不能通过算法将单项散列密文反计算得到明文，但是由于密码具有一定的模式，因此通过彩虹表（人们常用密码和对应的密文关系表）等手段可进行猜测式破解
> 为了加强安全性，还会给散列算法加盐（salt），salt相当于加密的密钥，增加破解难度

- 可以进行密码加密保存：当保存时进行加密保存，当用户登录时，对输入进行加密，和数据库中的密文进行比较，如果一致，则验证成功
- 常用的单项散列算法有MD5、SHA等

#### 对称加密
> 加密和解密的密钥是同一个（或者可相互推算）。常用在信息安全需要交换或存储的场合，如Cookie加密、通信加密

- 优点是算法简单，加密效率高，系统开销小，适合对大量数据加密。缺点是使用同一个密钥，远程通信的情况下如何安全的交换密钥
- 常用的对称加密算法有DES算法、RC算法。是一种传统的、最常用加密手段，适用于绝大多数需要加密的场合

#### 非对称加密
> 加密和解密使用的密钥不是同一个， 公钥对外界公开，私钥只有所有者知道。用公钥加密的信息必须用私钥解开，用私钥加密的信息只能用公钥解开。理论上不可能通过公钥计算出私钥

- 通常用在信息安全传输、数字签字等场合。在实际应用中，通常会混合使用对称加密和非对称加密，先使用非对称加密对对称密钥进行安全传输，然后使用对称加密技术进行信息加解密与交换。有时对同一个数据两次使用非对称加密，可同时实现信息安全传输与数字签名的目的
- HTTPS传输中浏览器使用的数字证书实质上也是非对称加密的公钥
- 常用算法有RSA等

#### 密钥安全管理
前几个加密技术，能达到安全保密效果的一个重要前提是密钥的安全，不管是单项散列的salt、对称加密的密钥、非对称加密的私钥，一旦泄露出去，加密的信息都失去了秘密性

改善密钥安全性的手段（什么鬼方法）：
1. 第一种方法是密钥和算法房子啊一个独立的服务器上，对外提供加密和解密的服务，由专人维护，使得密钥邪路的概率大大降低。但是成本较高，而且可能会成为应用的瓶颈，每次加密解密都需要调用一次远程服务
2. 第二种方法是加解密算法放在应用系统中，密钥则放在独立服务器中，为了提高密钥的安全性，在实际存储时，密钥被切分成数片，加密后分别保存在不同的密钥存储服务器中，每个服务器由专人维护，没人能查看完整的密钥信息，兼顾安全性和性能

最不好的方法是明文保存在应用程序中，稍好一点的方法是保存在配置文件中，开发和线上环境使用不同的密钥

### 信息过滤与反垃圾
#### 文本匹配
主要解决敏感词过滤问题。网站维护一份敏感词列表，对敏感词金西行消毒（转为****）或拒绝发表
- 如果敏感词较少，可使用正则表达式，但是正则表达式的效率较差，当敏感词太多、发布的信息很长、并发量高时，就需要其他的算法
- 公开的算法基本上都是Trie树的变种，空间和时间复杂度都好的有双数组Trie算法等
- 更简单的实现是通过构造多级Hash表进行文本匹配。处理速度较快，适应各种过滤场景。缺点是Hash表会浪费部分内存空间，如果敏感词数量不多，这些内存还是可以接受的
- 有人为了绕过敏感词检查，输入如“中_国”这样的信息，对这些信息可以做降噪预处理，然后再匹配

#### 分类算法
> 对广告贴、垃圾邮件等内容的识别比较好的自动化方法是分类算法。以垃圾邮件为例，现将已分类的邮件样本（如50000封正常，2000封垃圾）输入分类算法进行训练，得到一个垃圾邮件分类模型，然后利用分类算法结合分类模型对邮件进行识别
> 分类算法还可用于信息自动分类

常用的分类算法那有贝叶斯分类算法，是一种利用概率统计方法金西行分类的算法

#### 黑名单
- 可通过Hash表实现，实现简单，时间复杂度小，满足一般场景使用，但是当黑名单列表太大，Hash表会占据极大的内存空间（如果有10亿个，每个需要8字节，就需要8GB的内存，为了减少Hash冲突，还需要一定的Hash空间冗余，如果空间利用率为50%，就需要16GB的内存你空间），而且列表越大，Hash冲突越多，检索速度越慢
- 在对过滤需求不完全精确的情况下，可用布隆过滤器代替Hash表，处理同样的信息，只需要Hash表所需内存的1/8，但是可能导致误判（检查在黑名单中，但实际却并放入过。可能性极小，通常在可接受范围内，但如果需要精确，则不能使用布隆过滤器）

### 电子商务风险控制
#### 风险
- 账户风险：账户被盗、恶意注册等
- 买家风险：买家恶意下单占用库存进行不正当竞争；黄牛利用促销抢购低价商品；良品拒收，欺诈退款
- 卖家风险：不良卖家进行恶意欺诈，例如货不对板，虚假发货，炒作信用，出售违禁品、侵权产品
- 交易风险：信用卡盗刷，支付欺诈，洗钱套现

#### 风控
手段包括人工和机器。机器自动识别为高风险的交易和信息会发送给风控审核人员进行人工审核

机器自动风控的技术手段主要有：
1. 规则引擎：当交易的某些指标满足一定条件时，就会被认为具有高风险的欺诈可能性，如用户来自欺诈高发地区，金额超过某个值，和上次登录的地址距离差距很大，用户登录地与收货地址不符，用户第一次交易等。大型网站在运营过程中，会总结出数以千计的高风险交易规则，如果使用if...else...代码来实现，会非常庞大且不利于维护，所以一般采用规则引擎技术来处理此类问题。规则引擎虽然技术简单（？？？），但是会出现规则冲突，难以维护等情况，而且规则越多，性能也越差
    > 规则引擎技术：将业务规则和规则处理逻辑相分离的技术，业务规则文件由运营人员通过管理界面编辑，当需要修改规则时，无需更改代码
    
2. 统计模型：现在大型网站更倾向于使用统计模型进行风控。使用分类算法或更复杂的机器学习算法进行智能统计。准确率不低于规则引擎，实时计算性能更好，但是对新出现的交易欺诈还具有一定的预测性

## 9 淘宝网的架构案例演化

- 2003：LAMP
- 2004：Oracle（需部署在昂贵的IBM小型机、EMC存储设备）、Java（MVC：自己开发的Webx，ORM：IBatis）；开发了构建工具Antx；应用服务器Weblogic。此时业务发展迅速，开发资源投入到业务开发上，而不是解决可以用付费产品搞定的技术技术问题上
- 后3-4年：放弃EJB（太笨重），使用Spring；用免费的JBoss替代收费的Weblogic（并非物有所值）；后来用更轻量的Jetty替代JBoss
- 之后：技术开始发力，奠定淘宝坚实架构基础的产品和技术开始出现并走向成熟：Tair（分布式KV存储引擎）、TFS（分布式文件系统，适用于海量小文件存储）、OceanBase（分布式数据库系统，支持千亿级别的读写事务）、TDDL（对应用透明的分库分表层和具有众多特性的动态数据源）。随着对集群环境下分布式高可用系统架构设计越来越得心应手，逐步放弃昂贵的Oracle、IBM、EMC，回归到开源的MySQL、NoSQL

## 10 维基百科的高性能架构设计分析
Wikipedia书非营利性的，所以尽可能使用免费或廉价的服务器和技术：GeoDNS、LVS、Squid、Lighttpd、PHP、Memcached、Lucene、MySQL

## 11 海量分布式存储系统Doris的高可用架构设计分析
## 12 网购秒杀系统架构设计案例分析（这里假设只能秒杀一件；可能解决方案较老）
### 技术挑战和应对策略
1. 对现有业务造成冲击：秒杀活动只是网站营销的附加活动，具有时间段、并发访问量大的特点，如果和网站原有应用部署在一起，必然会对现有业务造成冲击
    解决：秒杀系统独立部署
2. 高并发下的应用、数据库负载：用户不停刷新网页，这些请求会对应用服务器和数据库造成极大的负载压力
    解决：页面静态化。不使用网站原来的商品详情页面，页面内容静态化：将所有信息写入到一个静态页面，用户请求不经过应用服务器的业务逻辑处理，也不需要访问数据库。所以秒杀商品服务不需要部署动态的Web服务器和数据库服务器
3. 突然增加的网络及服务器带宽
    解决：网络带宽必须和运营商重新购买和租赁，需要将秒杀商品页面缓存在CDN，同样需要和CDN服务商临时租借新增的出口带宽
4. **直接下单**：在时间点之前，只能浏览商品信息，不能下单。而下单页面也是一个普通的URL，如果得到这个URL，不用等到秒杀也可以下单了
    解决：动态生成随机下单页面URL。将该URL动态化，无法在秒杀开始前访问下单页面URL，办法是在下单页面URL加入由服务器端生成的随机数作为参数，在秒杀开始时才能得到
#### 架构设计
秒杀用户更关心快速刷新商品页面，抢先进入下单页面，而不是商品详情等用户体验细节，因此秒杀系统页面设计尽可能简单，购买数量只能是一个且不能修改，送货地址和付款方式都使用用户默认设置，没有默认也可以不填，允许订单提交后更改；只有第一个提交的订单发送给网站的订单子系统，其余用户提交后只能看到秒杀结束的页面。

如何控制购买按钮的点亮：因为页面为静态，刷新的请求不会到达应用服务器，所以要通过JS脚本控制，在静态页面中加入一个JS文件引用，该文件中加入秒杀是否开始的标志和下单页面URL的随机数参数，当秒杀开始时生成一个新的JS文件并被用户浏览器加载，控制商品的展示。这个JS文件使用随机版本号，不被浏览器、CDN和反向代理服务器缓存。这个文件非常小，不会对服务器和带宽造成压力

如何只允许第一个提交的订单被发送到订单子系统：在用户提交订单时，检查是否已有订单提交。为了减轻下单页面服务器的负载压力，可以控制进入下单页面的入口，只有排名靠前的少数用户能进入下单页面，其他用户进入到秒杀结束页面

## 13 大型网站典型故障案例分析
大型网站的技术本质都很简单，没有很花哨的东西，掌握起来也不太难。大型网站架构师最有价值的地方不在于他们掌握了多少技术，而是他们经历过多少故障。在高并发和海量数据的情况下，很多一般情况下不是问题的问题都会涌现出来

### 写日志也会引发故障
日志文件会迅速增加，不断消耗磁盘空间

经验教训：
1. 应用程序自己的日志输出配置要和第三方组件日志输出要分别配置
2. 日志输出级别至少为Warn，并且检查log输出代码调用，调用级别要符合其真实日志级别
3. 有些开源的第三方组件也会输出太多Error日志，需要关闭他们的日志输出

### 高并发访问数据库引发的故障
当应用发布后，数据库Load居高不下。发现时因为某条sql引起的，这条sql执行频率非常高，发现这条sql被网站首页调用，首页是访问最频繁的网页，sql被频繁执行

经验教训：
1. 首页不应该访问数据库。首页的数据应该从缓存服务器或搜索引擎服务器获取
2. 首页最好是静态的

### 高并发下锁银发的故障
某应用服务器不定时地因为响应超时而报警，但是很快又超时解除，回复正常，反复如此。原因是程序中有某个单例对象中多出使用了synchronized(this)，由于this只有一个，所有的并发请求都要排队获得这唯一的一把锁。一般情况下不会引起线程排队，但是当某个需要远程调用的操作也被加了synchronized(this)，就需要较长时间才能完成，锁被占用，所有用户线程都要等待，响应超时

经验教训：使用锁要谨慎

### 缓存引发的故障发
没有新应用发布，但是数据库服务器突然Load飙升，并很快失去响应。缓存服务器在网站服务器集群中地位比较低，配置和管理级别都比其他服务器要低一些，丢失一些缓存也没什么问题，关闭一些缓存服务器也没有明显影响。结果一位缺乏经验的工程师关闭了缓存服务器集群的全部十几台花村服务器，导致网站全部瘫痪

经验教训：当缓存已成为网站架构不可或缺的一部分，而不仅仅是改善性能时，对缓存的管理就需要提高到和其他服务器一样的级别

### 应用启动不同步引发的故障
应用发布后，服务器立即崩溃。原因是后台服务还没有全部启动起来，前台应用就已经开始启动，导致崩溃

经验教训：在前台（相对）应用启动之前，先在脚本中不断用curl命令访问特定页面，直到接收到OK，才启动前台

### 大文件读写独占磁盘引发的故障
用户表示管理图片功能的上传图片非常慢。图片需要使用存储，最可能出错的地方时存储服务器，检查存储服务器发现大部分文件只有几百k，但是有几个文件非常大，读写他们一次需要几十秒，磁盘都被这个文件独占，导致其他文件操作缓慢

经验教训：存储的使用需要根据不同文件类型和用途进行管理，图片等小文件应该使用专用的存储服务器。批处理用的大文件可以使用其他类型的分布式文件系统

### 滥用生产环境引发的故障
监控发现某个时段内，某些应用突然变慢，内部网络延迟非常厉害。是以为有工程师在生产环境进行性能压力测试，占用了大部分交换机宽带

经验教训：线上生产环境要规范，不小心就会导致大事故

### 不规范的流程引发的故障
应用发布后，数据库Load飙升，回滚发布后报警消除。原因是工程师为了开发方便，将缓存注释掉了，结果直接提交到了生产环境

经验教训：
1. 提交代码前使用diff进行代码比较
2. 加强code review

### 不好的编程习惯引发的故障
1. 处理一个输入对象时，如果不能明确该对象是否为空，必须做空指针判断
2. 调用其他方法时，输入的对象尽量保证不是null，必要时构造空对象
                      
