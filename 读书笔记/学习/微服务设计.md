# 微服务设计（2016）
[TOC]

## 前言
微服务是一种分布式系统解决方案，推动细粒度服务的使用，这些服务协同工作，都有自己的生命周期

虽然基础设施自动化、测试和持续交付等技术很有用，但如果系统本身的设计不支持快速变化，那所做的事情将会受到很大限制

## 第一章 微服务
- 使用微服务时，内聚很重要：把因相同原因而变化的东西聚合到一起，而把不同原因而变化的东西分离开来
- 根据业务的边界拉来确定服务的便捷
- 一个微服务就是一个独立的实体，可以独立地部署在PAAS上，也可作为一个操作系统进程存在。服务之间通过网络调用通信，加强服务之间的隔离性，避免紧耦合
- 可以彼此间独立进行修改，某一服务的部署不应该引起该服务消费方的变动
- 对于一个服务来说，需要考虑什么应该暴露，什么应该隐藏
- 服务暴露出API（应用编程接口），服务之间通过API通信，API实现技术英爱避免与消费方耦合，选择与具体技术不相关的API实现方式，以保证技术的选择不被限制（解耦API）

### 好处
1. 技术异构性：可以在不同服务中使用最适合该服务的技术。如果尝试使用一种适合所有场景的标准化技术，会使得所有的场景都无法得到很好的支持（例如使用不同的存储：社交网络使用图数据库，帖子使用文档数据库）；还可以更快地使用新技术而不用修改整个系统
2. 弹性：可以很好地处理服务不可用和功能降级问题
3. 扩展：单服务只能作为一个整体进行扩展，而较小的多服务只对需要扩展的服务进行扩展
4. 简化部署：单块应用程序中，只修改了一行代码都需要重新部署整个应用。在微服务中，服务独立部署
5. 与组织结构相匹配：微服务可以很好地将架构与组织结构想匹配，避免出现过大的代码库，获得理想的团队大小以及生产力
6. 可组合性
7. 对可替代性的优化：微服务中重写或移除一个或多个服务的阻碍很细小

### 面向服务的架构（SOA）
一种设计方式，包含多个服务，服务之间通过配合最终会提供一系列功能，一个服务以独立的形式存在于操作系统进程中。服务之间通过网络调用，而非进程内调用

可以应对同种的单块应用程序，多个终端用户应用程序可共享同一个服务。目标是在不影响其他任何人的情况下透明地替换一个服务，只要替换后外部接口没有变化即可

### 其他的分解技术
1. 共享库：将整个代码分解为多个库。不同的服务通过库的形式共享功能。缺点：1）无法选择异构的技术，这些库只能用在同一种语言中。2）每当库有更新时，都需要重新部署整个应用
2. 模块：有些语言提供了模块分解技术，允许对模块进行生命周期管理，可以在不停止整个进程的前提下对某个模块进行修改。但是模块会迅速和其他代码耦合在一起，失去意义。1）OSGI是Java9的模块，它的复杂度远远大于带来的好处。2）Erlang，模块内嵌在语言的运行时中，可以对模块进行停止、重启、升级。但是还是会吸纳之采用新技术和独立服务进行扩展的能力

## 第2章 演化式架构师
架构师必须改变那种从一开始就要设计出完美产品的想法，应该设计出一个合理的框架，在这个框架下可以慢慢演化出正确的系统，并且一旦学到了更多知识，应该可以很容易地应用到系统中

### 分区
区域指服务边界。架构师不应该过多关注每个区域内发生的事，应该多关注区域之间的事，应该考虑不同的服务之间如何交互（交互要统一？）

## 第3章 如何建模服务
低耦合：服务之间低耦合，修改一个服务不需要修改另一个
高内聚：把相关的行为聚集在一起，不相关的行为放在别处，当需要新修改某个行为时，能够只在一个地方进行修改

- 不要过早划分，当有了非常稳定的边界，再将这个单块系统拆分为多个微服务
- 应该从能够供提供的功能来考虑，而不是从共享数据的角度来考虑界限
- 逐步划分：先拆分比较大的、粗粒度的服务，当发现合适的缝隙后，在进一步划分 

## 第4章 集成
DRY Don't Repeat Yourself.

### 不同的接口共存
不推荐同时维护三个版本的接口。在内部把所有对V1的请求进行转换处理，然后去访问V2，继而对V2进行处理，去访问V3，使用这种方式，将来该删除哪些代码也比较清楚了

## 第5章 分解单块系统
### 重构数据库
先分离数据库结构，然后再对服务进行分离。如果有不合理的可以回退，以免对消费者造成影响

## 第5章 部署

### 继续集成和微服务（jenkins、selenium）
持续集成CI（Continuous Integration）：保证新提交的代码与已有代码进行集成，让所有人保持同步，CI服务器会检测到新代码提交，然后验证代码是否通过编译以及测试能否通过。ci可以生成自动化二进制文件，用于生成这些构建物所有代码都在版本的控制之下，可重新生成这个版本的构建物。通过CI能够从已部署的构建物回溯到相应的代码。更快速、更容易地修改代码

每个微服务都有一个源代码库和CI构建

### 构建流水线和持续交付
把一个构建分成多个阶段，得到`构建流水线`，在第一阶段运行快速测试，第二阶段运行耗时测试。避免快速测试等待耗时测试，无法得到快速的反馈等问题。

持续交付CD（Continuous Delivery）：检查每次提交是否达到了部署到生产环境的要求，并持续把信息反馈给我们，把每次提交当做候选发布版本来对待。在CD中，把多阶段构建流水线的概念进行扩展，覆盖软件通过的所有截断，无论是手动还是自动。编译及快速测试-->耗时测试-->用户验收测试-->性能测试-->生产环境

### 平台特定的构建物
大多数技术栈都有相应的构建物类型，有相关的工具来创建和安装他们。Ruby有gem，Java有JAR包和WAR包，Python有egg，Node.js有NPM包。会带来问题：不同技术栈的服务需要多个完全不同的部署机制

操作系统构建物：RedHad/CentOS使用RPM，Ubuntu使用deb包，Windows使用MSI。好处是部署时不需要考虑底层的使用什么技术，只需要简单的内置工具就可以完成软件的安装。缺点是开始编写构建脚本比较困难，而且Windows上打包比较麻烦；需要维护不同平台的构建物。如果软件是给别人安装的，别无选择，如果是部署在自己可控的机器上，就尽可能减少需要维护的操作系统的数量

定制化镜像：为了避免一次次的安装工具浪费时间，可使用镜像，例如WMWare。缺点是构建镜像会花费大量时间、镜像可能会很大（n个G）。不推荐

### 服务与主机之间的映射
每台主机有多少个服务

1. 单主机多服务
优点：易于管理
缺点：1）监控困难，服务之间会相互影响，互相占用CPU。2）部署更加复杂，可能会影响到其他服务。3）不同团队的服务安装在同一机器，需要更多的协调。4）限制部署构建物的选择。5）增加对单个服务进行扩展的复杂性

2. 应用程序容器
把容器（如Java的servlet）放置到单台主机上，初衷是使用容器来简化管理，比如对多实例提供集群支持、监控等。缺点是限制技术栈的选择，限制自动化和系统管理技术的选择

3. 每个主机一个服务
避免了多主机一个服务的问题，简化了监控和错误回复，一台主机宕机只会影响一个服务，可采用不同的部署技术，简化问题的排查。可减小微服务复杂性，单主机数量的增加也是问题，需要管理更多的服务器，但在使用微服务时仍然是较好的模型

4. 平台及服务PaaS
当PaaS正常工作时会工作得特别好，但是如果出现了问题，通常没办法通过操作底层操作系统来修复这些问题。越聪明，也可能错的越离谱

5. 自动化
自动化避免了多主机时手动部署、监控、日志收集时管理工作量翻倍的问题

1. 传统的虚拟化技术
类似AWS、VMWare等，把机器分成多台独立主机，每台主机可运行不同的东西

1. Linux容器
可创建一个隔离的进程空间。每个容器可运行不同的操作系统发行版，但必须共享相同的内核，相比虚拟机，可以启动得非常快，虚拟机最少几分钟，Linux容器只需要几秒；更轻量，运行的容器数量比虚拟机数量大得多；对资源的利用更加高效。缺点是容器之间并不是完全隔离的，可能会与其他容器，甚至底层主机发生干扰

8. Docker
构建在轻量级容器之上的平台，帮你处理了大多数与容器管理相关的事。可在Docker中创建部署应用，管理容器的配置，并处理一些网络问题...
Docker并不能解决所有问题，只是一个在单机上运行的简单PaaS。还需要一些工具进行跨多台机器管理Docker容器

9. 使用统一接口
从本地开发测试到生产环境部署，不同环境的部署机制应该尽量相似。**参数化的命令行调用是触发任何部署最合理的方式**，可使用CI工具来触发脚本的调用，或手动键入（bash或Python Fabric）
Fabric: 作者使用最多的工具，是一个被设计用来将命令行调用映射到函数的Python库，同时提供类似SSH这样的机制来控制远程服务器。结合Boto这样的AWS客户端，就可以完全自动化大型AWS环境。Windows可使用PowerShellp
环境定义：相当于微服务到计算、网络、存储资源之间的映射。使用yaml文件进行描述，使用脚本从中获取数据（hashicorp可帮你做这样的事）
例:

```yaml
development:
    nodes:
    - ami_id: ami-ele1234
      size:
      ...

production: 
    nodes:
    -  ami_id:
       size:
       ...
```

## 第7章 测试