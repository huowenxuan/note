[TOC]

# 重构：改善既有代码的设计

## 第2章 重构原则
- 重构有两种定义
    1. 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。是对软件的小改动
    2. 使用一系列重构手法，在不改变软件可观察行文的前提下，调整其结构

- 为何重构
    1. 改进软件设计： 整理代码，消除重复
    2. 使不熟悉的代码更容易理解
    3. 深入理解代码的作为，帮助找到bug
    4. 提高编程速度，**良好的设计是维持软件开发的根本**

- 何时重构：随时随地，不应该为重构而重构。**重构之前，代码必须起码能在大部分情况下正常运作**
    - 三次法则：事（同一件事）不过三，三则重构
    - 添加功能时：让未来增加新特性时更轻松一些
    - 修补错误时
    - 复审代码时

- 何时不应该重构
    - 既有代码太混乱、根本不能正常运作，就需要重写（非重构）。折中的办法是，将大块头软件封装为小组件，逐一对组件进行重构
    - 项目接近最后期限

## 第3章 代码的坏味道
- 过长函数
    - “间接层”带来的全部利益——解释能力、共享能力、选择能力，都是由小函数支持的
    - 让小函数容易理解的真正关键在于一个好名字
    - **原则：每当感觉需要以注释来说明点什么的时候，就把要说明的东西写进一个独立函数中**
- 软件一旦修改，需要进行多处改动
- 几乎没用的类、组件，应该消失
- 暂时字段：某个实例变量仅为某种特定情况而设，应该把所有和这个变量相关的代码都提炼为一个新的类
- 过多的注释。有些注释是因为代码太糟糕
- 重复代码、过大的类、过多参数（可使用对象封装）、两个类过于亲密、两个函数做同一件事…

## 第4章 构筑测试体系
要进行重构，首要前提就是拥有一个可靠的测试环境。编写优良的测试程序，可以极大提高编程速度，即使不进行重构也一样

- 自测试代码的价值
    - 每个类都应该有一个测试函数，但可能不好操控。更好的做法是：建立一个独立类用于测试，并在一个框架中运用它，使测试工作更轻松
    - 每次编译后都进行自动化测试，因为测试本来是可以正常运行的，当出现新的错误后，就会知道这个错误肯定是在前一次执行测试后引入的，所以能很轻松的找到错误，很少花时间在调试上面
    - **编写测试代码最有用的时机是在开始编程之前**，告诉自己这个功能需要做什么，还能把注意力集中于接口而非实现，一旦测试代码正常运行，工作就可以结束了

- 针对任何一项功能的任何一种失败的可能情况进行测试。不同于某些人提倡的“测试所有public函数”

- 测试应该是一种风险驱动行为，目的是可能出现的错误，太简单的函数不必写测试。**测试最担心出错的部分**

- 寻找边界条件

- 检查预期的错误是否如期出现

## 第5章 重构列表

- 使用一种格式来介绍重构
     - 名称。（针对不同的重构目标搭建重构词汇表）
     - 简短概要。1）帮助解决的问题。2）应该做的事。3）展示重构前后的代码或UML
     - 动机。为什么需要这个重构，什么情况下不应该使用这个重构
     - 做法。简明扼要地一步步介绍如何重构
     - 范例。一个十分简单的例子说明如何运作

- 重构的基本技巧：小步前进、频繁测试

## 第6章 重新组织函数
### 提炼函数（格式范例）
将一段可被组织并独立出来的代码放进一个独立函数中，并让函数名称解释该函数的用途

```java
// 旧代码
```
↓

```java
// 新代码
```

#### 动机
如果函数的粒度小，那么被复用的机会就更大，覆写也会更容易
函数名长度不是问题，关键在于函数名称和函数本体之间的语义距离
只有能给小型函数很好地命名时，它们才能真正起作用

#### 做法
* 一个函数，以它“做什么”来命名（而不是“怎么做”）
    > 即使要提炼的代码非常简单，例如只是一个函数调用。只要新函数的名称能更好的表示代码意图，就应该提炼他，但如果想不出一个更有意义的名称，就别动  

* ...
* 编译，测试

#### 范例：无局部变量
…

#### 范例：有局部变量
…

### 内联函数
以简短的函数表现动作意图，会使代码更清晰易读，但是有些函数，其内部实现和函数名称同样清晰易读，就应该去掉这个函数，直接使用其中的代码。**间接性能带来帮助，但非必要的间接性会让人不舒服**

当手上有一群组织不合理的函数，可以将它们都内联到一个函数中，再从中提炼小函数

### 以查询取代临时变量
有一个临时变量保存某一表达式的运算结果，要将这个表达式提炼到一个函数中，来替代临时变量。`let basePrice = a * b; => basePrice() { return a * b; }`

### 引入解释性变量
将复杂表达式或其中的一部分放进一个临时变量。复杂表达式难以阅读，临时变量名可以用来解释表达式用途

### 分解临时变量
如果有临时变量被赋值超过一次（除了for），针对每次赋值，创造一个独立、对应的临时变量。如果变量承担多个责任，就应该被分解为多个变量

### 移除对参数的赋值
代码对一个参数进进行赋值，以一个临时变量取代该参数的位置

```
func(int val) {
    if (val > 50) val = {}
}
```

⬇️

```
func(int val) {
    int result = val
    if (val > 50) result = {}
}
```

上面的代码降低了代码的清晰度，而且混用了安置传递和引用传递这两种参数的传递方式

## 第7章 在对象之间搬移特性

### 搬移函数
有个函数与另一个类有更多的交流：在另外一个类中建立一个有类似行为的新函数，将旧函数变成一个单纯的委托函数，或完全移除。
“搬移函数”是重构理论的支柱。如果一个类有太多行为，或如果一个类与另一个类有太多合作而形成高度耦合，就要搬移函数

### 搬移字段
某个字段被另外一个类更多的用到：在目标类新建一个字段，修改源字段所有用户，让它们使用新字段

### 提炼类
某个类做了两个类的事：提炼为两个类

### 将类内联化
某个类没有做太多事：将这个类的所有特性搬到另一个类中，移除原类

### 隐藏委托关系
客户通过一个委托类来调用另一个对象：在服务类上建立客户所需的所有函数，用以隐藏委托关系，将来即便委托关系发生变化，变化也将会被限制在服务对象中。
**“封装”意味着每个对象都应该尽可能少了解系统的其他部分**，一旦发生变化，需要进行的改动也较少

### 移除中间人
隐藏委托关系也有代价：随着功能增加，委托函数越来越多，服务类完全变成了中间人，此时就应该让客户直接调用受托类

### 引入本地扩展
需要为某个类提供一些额外函数，但无法修改这个类：建立一个新类，使它包含这些额外函数，让这个扩展类称为源类的子类（继承）或包装类（委托），统称为本地扩展
本地扩展必须坚持**函数和数据应该被统一封装**的原则。如果零散的放置，会变得过于复杂、难以复用
首选字类，工作量较少，不会波及原对象。如果需要同时改变原对象，就要用包装类

