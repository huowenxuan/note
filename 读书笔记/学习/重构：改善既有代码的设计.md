[TOC]

# 重构：改善既有代码的设计

## 第2章 重构原则
- 重构有两种定义
    1. 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。是对软件的小改动
    2. 使用一系列重构手法，在不改变软件可观察行文的前提下，调整其结构

- 为何重构
    1. 改进软件设计： 整理代码，消除重复
    2. 使不熟悉的代码更容易理解
    3. 深入理解代码的作为，帮助找到bug
    4. 提高编程速度，**良好的设计是维持软件开发的根本**

- 何时重构：随时随地，不应该为重构而重构。**重构之前，代码必须起码能在大部分情况下正常运作**
    - 三次法则：事（同一件事）不过三，三则重构
    - 添加功能时：让未来增加新特性时更轻松一些
    - 修补错误时
    - 复审代码时

- 何时不应该重构
    - 既有代码太混乱、根本不能正常运作，就需要重写（非重构）。折中的办法是，将大块头软件封装为小组件，逐一对组件进行重构
    - 项目接近最后期限

## 第3章 代码的坏味道
- 过长函数
    - “间接层”带来的全部利益——解释能力、共享能力、选择能力，都是由小函数支持的
    - 让小函数容易理解的真正关键在于一个好名字
    - **原则：每当感觉需要以注释来说明点什么的时候，就把要说明的东西写进一个独立函数中**
- 软件一旦修改，需要进行多处改动
- 几乎没用的类、组件，应该消失
- 暂时字段：某个实例变量仅为某种特定情况而设，应该把所有和这个变量相关的代码都提炼为一个新的类
- 过多的注释。有些注释是因为代码太糟糕
- 重复代码、过大的类、过多参数（可使用对象封装）、两个类过于亲密、两个函数做同一件事…

## 第4章 构筑测试体系
要进行重构，首要前提就是拥有一个可靠的测试环境。编写优良的测试程序，可以极大提高编程速度，即使不进行重构也一样

- 自测试代码的价值
    - 每个类都应该有一个测试函数，但可能不好操控。更好的做法是：建立一个独立类用于测试，并在一个框架中运用它，使测试工作更轻松
    - 每次编译后都进行自动化测试，因为测试本来是可以正常运行的，当出现新的错误后，就会知道这个错误肯定是在前一次执行测试后引入的，所以能很轻松的找到错误，很少花时间在调试上面
    - **编写测试代码最有用的时机是在开始编程之前**，告诉自己这个功能需要做什么，还能把注意力集中于接口而非实现，一旦测试代码正常运行，工作就可以结束了

- 针对任何一项功能的任何一种失败的可能情况进行测试。不同于某些人提倡的“测试所有public函数”

- 测试应该是一种风险驱动行为，目的是可能出现的错误，太简单的函数不必写测试。**测试最担心出错的部分**

- 寻找边界条件

- 检查预期的错误是否如期出现

## 第5章 重构列表

- 使用一种格式来介绍重构
     - 名称。（针对不同的重构目标搭建重构词汇表）
     - 简短概要。1）帮助解决的问题。2）应该做的事。3）展示重构前后的代码或UML
     - 动机。为什么需要这个重构，什么情况下不应该使用这个重构
     - 做法。简明扼要地一步步介绍如何重构
     - 范例。一个十分简单的例子说明如何运作

- 重构的基本技巧：小步前进、频繁测试

## 第6章 重新组织函数
### 提炼函数（格式范例）
将一段可被组织并独立出来的代码放进一个独立函数中，并让函数名称解释该函数的用途

```java
// 旧代码
↓
// 新代码
```

#### 动机
如果函数的粒度小，那么被复用的机会就更大，覆写也会更容易
函数名长度不是问题，关键在于函数名称和函数本体之间的语义距离
只有能给小型函数很好地命名时，它们才能真正起作用

#### 做法
* 一个函数，以它“做什么”来命名（而不是“怎么做”）
    > 即使要提炼的代码非常简单，例如只是一个函数调用。只要新函数的名称能更好的表示代码意图，就应该提炼他，但如果想不出一个更有意义的名称，就别动  

* ...
* 编译，测试

#### 范例：无局部变量
…

#### 范例：有局部变量
…

### 内联函数
以简短的函数表现动作意图，会使代码更清晰易读，但是有些函数，其内部实现和函数名称同样清晰易读，就应该去掉这个函数，直接使用其中的代码。**间接性能带来帮助，但非必要的间接性会让人不舒服**

当手上有一群组织不合理的函数，可以将它们都内联到一个函数中，再从中提炼小函数

### 以查询取代临时变量
有一个临时变量保存某一表达式的运算结果，要将这个表达式提炼到一个函数中，来替代临时变量。`let basePrice = a * b; => basePrice() { return a * b; }`

### 引入解释性变量
将复杂表达式或其中的一部分放进一个临时变量。复杂表达式难以阅读，临时变量名可以用来解释表达式用途

### 分解临时变量
如果有临时变量被赋值超过一次（除了for），针对每次赋值，创造一个独立、对应的临时变量。如果变量承担多个责任，就应该被分解为多个变量

### 移除对参数的赋值
代码对一个参数进进行赋值，以一个临时变量取代该参数的位置

```
func(int val) {
    if (val > 50) val = {}
}
⬇️
func(int val) {
    int result = val
    if (val > 50) result = {}
}
```

上面的代码降低了代码的清晰度，而且混用了安置传递和引用传递这两种参数的传递方式

## 第7章 在对象之间搬移特性

### 搬移函数
有个函数与另一个类有更多的交流：在另外一个类中建立一个有类似行为的新函数，将旧函数变成一个单纯的委托函数，或完全移除。
“搬移函数”是重构理论的支柱。如果一个类有太多行为，或如果一个类与另一个类有太多合作而形成高度耦合，就要搬移函数

### 搬移字段
某个字段被另外一个类更多的用到：在目标类新建一个字段，修改源字段所有用户，让它们使用新字段

### 提炼类
某个类做了两个类的事：提炼为两个类

### 将类内联化
某个类没有做太多事：将这个类的所有特性搬到另一个类中，移除原类

### 隐藏委托关系
客户通过一个委托类来调用另一个对象：在服务类上建立客户所需的所有函数，用以隐藏委托关系，将来即便委托关系发生变化，变化也将会被限制在服务对象中。
**“封装”意味着每个对象都应该尽可能少了解系统的其他部分**，一旦发生变化，需要进行的改动也较少

### 移除中间人
隐藏委托关系也有代价：随着功能增加，委托函数越来越多，服务类完全变成了中间人，此时就应该让客户直接调用受托类

### 引入本地扩展
需要为某个类提供一些额外函数，但无法修改这个类：建立一个新类，使它包含这些额外函数，让这个扩展类称为源类的子类（继承）或包装类（委托），统称为本地扩展
本地扩展必须坚持**函数和数据应该被统一封装**的原则。如果零散的放置，会变得过于复杂、难以复用
首选字类，工作量较少，不会波及原对象。如果需要同时改变原对象，就要用包装类

## 第8章 重新组织数据
### 自封装字段
为一个字段设置setter和getter
直接访问与间接访问各有好处：
- 直接访问：代码容易阅读
- 间接访问：可以直接修改这个函数而改变获取的数据；懒加载

### 以对象取代数据值
有一个数据项，需要与其他数据和行为一起使用才有意义，需要讲数据项变成对象

比如刚开始只需要用一个字符串来表达“电话号码”，后来需要格式化、抽取区号，就需要把电话相关的数据和函数封装为对象

### 将值对象改为引用对象
从一个类中产生出很多相等的实例：把它们替换为引用对象

```javascript
_customer = new Customer(name)
_customer.getName()
👇
_name = Customer.getName()
```

### 将引用对象改为值对象
当引用对象难以管理难以使用时改为值对象。在分布系统和并发系统中，不可变的值对象特别有用，不用考虑同步问题

达到不可变：不是某个变量不可变，而是要改变它，必须使用新的对象来取代现有对象

### 以对象取代数组
一个数组，其中的元素各自代表不同的东西：以对象代替数组，对于每个元素，以一个字段表示

### 以字面常量取代魔法数
有一个带有特别含义的数值，将它变为常量

### 封装字段
将public字段声明为private，并提供访问函数

面向对象首要原则就是封装，或者称为“数据隐藏”，**绝不应该将数据声明为public**，避免其他对象访问或修改数据，数据和行为会被分开，降低模块化程度

### 封装集合
有个函数返回一个集合，让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。不该返回集合自身，会让其他人修改集合；不该提供直接设值函数

```js
Person p = new Person();
Set s = new Set();
s.add(new Course());
s.add(new Course());
p.initializeCourses(s);
⬇️
Person p = new Person();
p.addCourse(new Course);
```

### 以类取代类型码
类型码无法进行类型检验，降低代码可读性，容易产生bug

```javascript
// 血型
static count O = 0; 
static count A = 1;
static count B = 2;
static count AB = 3;
👇
static count O = Blood.O;
static count A = Blood.A;
static count B = Blood.B;
static count AB = Blood.AB;
```

### 以字段取代子类
一个父类的各个子类的差别只是一个函数返回了不同的常量数据。例如A返回“a”，B返回“b”。去掉这些子类，修改父类中的该函数（增加新的参数用来返回不同的常量数据）

子类没有存在价值，子类是为了增加新特性或改变行为

## 第9章 简化条件表达式
### 分解条件表达式
从复杂的if/else中分别提炼出独立的函数

### 合并条件表达式
一系列if都得到相同的结果，将他们用或/与合并为一个表达式，并将这个条件表达式合并为一个独立函数

```
if (a < 2) return 0
if (b < 2) return 0
if (c < 2) return 0
⬇️
if ( lessThen(2) ) return 0
```

### 合并重复的条件片段
将if/else中重复的代码提到外面

### 移除控制标记
在一系列布尔表达式中，使用break/return取代控制标记flag

### 以卫语句取代嵌套条件表达式

```javasript
let result;
if (a)result = a;
else {
    if (b) result = b;
    else {
        if (c) result = c;
        else result = 0;
    }   
}
return a;
👇
if (a) re图urn a;
if (b) return b;
if (c) return c;
```

### 以多态取代条件表达式
条件表达式根据对象类型的不同选择不同的行为——将表达式的每个分支都放进对应的子类的覆写函数中

### **引入Null对象**
需要检查某个对象是否为空——在源类添加isNull函数

```
if (customer === null)
// TO
if (customer.isNull())
```

### 引入断言
只有某个条件为真时，代码才能正常运行——以断言明确表明。程序最后的成品往往会把断言删除。断言有助于交流（编写测试代码后，断言在调试方面不太重要了）

```java
/* should not null */
return a;
// TO->
Assert.isTrue(a != NULL);
return a;
```

## 第10章 简化函数调用

### 移除参数
不需要的参数就移除掉。多余的参数虽然不会有任何问题，但是会更操心

### **将查询函数和修改函数分离**
要明确表现出“有副作用”和“无副作用”两种函数之间的差异：任何有返回值的函数，都不应该有看得到的副作用

### 以明确函数取代参数
有一个函数，其中完全取决于数值而采取不同的行——针对每一个可能值，建立一个独立函数

### 保持对象完整
从某个对象中取出若干值，将它们作为某一次函数调用时的参数——改为传递整个对象

### 引入参数对象
某些参数总是同时出现——以一个对象取代这些参数

```
a(start: Date, end: Date)
b(start: Date, end: Date)
👇
a(DateRange)
b(DateRange)
```

### 隐藏函数
有个函数，从未被其他类调用过——将这个函数改为private

### 以工厂函数取代构造函数
希望在创建对象时不仅仅是做简单的建构动作、以工厂函数取代类型码

```
Employee(int type) {
    _type = type;
}
👇
static Employee create(int type) {
    return new Employee(type);
}
```

### 以异常取代错误码

### 以测试取代异常（以检查(if)取代异常）
可以预先检查的条件，你却抛出了一个异常——先做检查再执行

## 第11章 处理概括关系（继承关系）

### 字段上移
两个子类都有相同的字段——将该字段移至父类

### 函数上移/构造函数本体上移
函数在各个子类中产生完全相同的效果——将该函数移至父类

### 函数下移/字段下移
父类中的某个函数只与部分子类有关——将这个函数移到子类中

### 提炼子类
类中的某些特性只被某些实例用到——新建一个子类，将那些特性移过去

### 提炼超类
两个类有某些相似特性——建立一个超类，将相同的特性移至超类

## 第12章 大型重构
大型重构可能会花费很多时间，有必要为整个开发团队建立共识，为修改指定方向，整个团队都必须意识到：有一个大型重构正在进行，每个人都应该相应地安排自己的行动

重构绝不是因为好玩，而是希望它对程序有所帮助，能做一些重构之前无法做的事情

### 梳理并分解继承体系
某个继承体系同时承担两个责任——建立两个继承体系，并通过委托关系让其中一个可调用另一个

### 将过程化设计转为对象设计
有一些传统过程化风格的代码——将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象中（过时）

### 将领域和表述/显示分离
某些GUI类中包含了领域逻辑——将领域逻辑分离i 出来，为他们建立独立的领域类（MVC）

### 建立继承体系
有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的——建立继承体系，以一个子类表示一种特殊情况（重复）